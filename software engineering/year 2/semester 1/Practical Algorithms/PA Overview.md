**Slides**
[[Software Engineering/Year 2/Practical Algorithms/Slides/1. Introduction & Warming Up/Introduction to Algorithms.pdf]]
[[Software Engineering/Year 2/Practical Algorithms/Slides/1. Introduction & Warming Up/Course Organisation.pdf]]
#### Defining an "Algorithm"
A procedure for solving a (mathematical) problem in a finite number of steps that frequently involves repetition of operations.

broadly: a **Step-by-step** method for accomplishing tasks.

e.g.
- Recipe for a dish
- Multiple numbers (imagine long multiplication, it's got a process behind it)

#### Importance of Algorithms
If we can specify an algorithm to solve a problem, we can then automate it's solution - because now we can tell a machine to do it for us.

#### What is Computer Science? Where Do *ALGORITHMS* Fit in the Picture?
Computer science is the study of Algorithms, including:

1. Their mathematical and formal properties.
	- Studying algorithms to determine they are correct and efficient.
2. Their hardware realizations
	- Designing computer systems able to realize algorithms.
3. Their linguistic realizations
	- Designing languages and translating algorithms into languages.
4. Their Application
	- Identifying problems and design software to solve these.

Software Engineering often has a higher emphasis on *#4*

#### The Story of Babbage
Story quoted from [britannica](https://www.britannica.com/biography/Charles-Babbage) -

> The idea of mechanically calculating mathematical tables first came to Babbage in 1812 or 1813. Later he made a small calculator that could perform certain mathematical computations to eight decimals. 
> 
> Then in 1823 he obtained government support for the design of a projected machine, the [Difference Engine](https://www.britannica.com/technology/Difference-Engine), with a 20-decimal capacity. The Difference Engine was a digital device: it operated on [discrete](https://www.britannica.com/dictionary/discrete) digits rather than smooth quantities, and the digits were decimal (0–9), represented by positions on toothed wheels rather than binary digits ("bits"). When one of the toothed wheels turned from nine to zero, it caused the next wheel to advance one position, carrying the digit. 
> 
> Like modern computers, the Difference Engine had storage—that is, a place where data could be held temporarily for later processing.

#### Some Key Figures
Alan Turing (Flash backs to **CANS**)
David Hilbert
Kurt Gödel
Stephen Kleene
Alzono Church

#### This Course and Algorithms
- Understanding Algorithms
- Writing and Programming Algorithms
- Analyzing Algorithms
- Data Structures working alongside Algorithms
- Developing basic concepts of logic and math's
- Developing skills in a computer language to solve using algorithms and data structures

#### Applications of Algorithms
A wee sample only…

- Optimization 
	- Shipping routes are only possible due to complex algorithms
	
- Operations Research
- Logistics
- Security
- Cryptography
- Computer Games Dev
- Special Effects
- ***GETTING THE MARS ROVER TO BEHAVE WHILE IT'S ON IT'S OWN***

- Designing robots to help people shop
	- Think more amazon less robots
	
- Simulating physics
	- Big Bang
	- Formation of Stars
	- Orbits (Remember the 10th planet changing simulated orbit - [source](https://www.sciencealert.com/new-evidence-suggests-that-our-solar-system-has-10-planets))

- Organ transplant list optimization
- ***GETTING HUMANS TO THE MOON***
- ***CAPTURING BLACK HOLES***
- Protistic work

#### Course Organization
Course Learning Outcomes - These don't map to Units:

**Two Categories:**

Practical
- Implementing basic data structures
- Using recursion as an algorithm design technique in a piece of software.
- Analyze and implement a range of algorithms.

Theory
- Use predicate logic, set theory and relational algebra to write assertions and use laws to prove
- Demonstrate an understanding of generated structures
- Deploy basic concepts of combinators in solving mathematical problems.

#### The Learning Plan
There will be considerate focus on problem based learning.
The scheduled class times will be divided into two types of sessions:

- Lecture + Problem Solving (most-days)
- "Get-a-tick" days (mostly Wednesdays, focused entirely on problem-solving)

#### Feedback and Course Changes
You will get feedback in the following ways:

- 1-1 and group feedback from course instructors and tutors:
	- > 50% contact hours dedicated to tutorial/lab.
- Peer feedback
- Individual Grade
- Overall general coursework comments
- Automated feedback in class test
- Grade feedback on exam
- Overall, general feedback on exam
- Office hours (by request)

**Course changes from last year**
- Project-based passement "**added**" (brought back)

# Table of Contents

## Units

### 1. Introduction to Algorithms
- [[1. Writing Algorithms to solve problems]]
### 2. Algorithm Analysis
- [[2. Big-O Notation]]
### 3. Data Collections
- [[software engineering/year 2/Practical Algorithms/Units/3. Data Collections/3.3 Sets|3.3 Sets]]
- [[3.4 Functions and Relations]]
- [[3.5 The Computing Perspective]]
- [[3.6 Dynamic vs Static]]
- [[3.7 Trees]]
- [[3.8 Abstract Data Types]]
- [[3.9 Hash Tables]]
### 4. Sequences, Induction and Recursion
- [[4.2 Sequences, Recurrence Relations and Summations]]
- [[4.3 Induction]]
- [[4.4 Recursive Algorithms]]
- [[4.5 Proof by induction template]]
### 5. Searching and Sorting
- [[5.1 Why search and sort]]
- [[5.2 Searching]]
- [[5.3 Sorting]]

### [[6. Graphs]]

## 7. Counting
- [[7.1 Counting]]
- [[7.2 Permutations]]
- [[7.3 Combinations]]
- [[software engineering/year 2/Practical Algorithms/Units/7. Counting and Probability/7.4 Probability|7.4 Probability]]
# 8. Formal Reasoning
- [[8.1 Propositional Logic]]
- [[8.2 Predicate Logic & Quantifiers]]
- [[8.3 Rules of Inference]]

