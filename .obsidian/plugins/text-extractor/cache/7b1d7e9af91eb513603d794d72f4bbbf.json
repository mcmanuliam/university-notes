{"path":"Software Engineering/Year 2/Systems Programming/Slides/1. Learning C/Sanitizers.pdf","text":"Sanitizers Yehia Elkhatib COMPSCI2030 Systems ProgrammingStatic Analysis o A static analyzer reasons about the code without executing it o The compiler performs some static analysis every time you compile code § e.g. type checking o It is good practice to enable all warnings and make warnings errors § i.e. use the ﬂags -Wall -Werror § so the compiler can be most helpful in detecting bugs before execution o Some static analysis is too expensive to perform in every build Other static analysis enforces a particular coding guideline o We invoke the static analyzer using a ﬂag and specifying the output format of the report: clang --analyze --analyzer-output html program.c clang static analyzer report o The tool generates a report explaining potential bugs Here the tool has reported a “garbage value” which in this case leads to undeﬁned outcome for an if-branch clang-tidy o A linter (the name comes from the first UNIX tool to perform static analysis on C) o clang-tidy is a flexible tool that allows to enforce coding guidelines and to modernize source code § It is possible to extend clang-tidy by writing your own checks o It is invoked like clang, accepting the same flags but after two dashes: -- o A series of checks can be enabled / disabled o Detailed information is available at: http://clang.llvm.org/extra/clang-tidy/ $ clang-tidy -checks=\"readability-*\" 6.c -- -Wall -Werror /Users/lito/Desktop/examples/6.c:2:16: warning: pointer parameter 'p' can be pointer to const [readability-non-const-parameter] void test(int *p) { ~~~ ^ const /Users/lito/Desktop/examples/6.c:4:9: warning: statement should be inside braces [readability-braces-around-statements] if (p)^{ Here we enable the checks for readability It suggests to to use const and put braces around the branch of an if statement Use the analyzer to improve your codeDynamic Analysis Tools o There exists a family of bug detection tools that use dynamic analysis o These tools need the program to run and can only detect bugs which are encountered during the execution of a particular test input o The clang project calls these tools sanitizers. The most important are: § AddressSanitizer - a memory error detector § MemorySanitizer - a detector of uninitialized reads § LeakSanitizer - a memory leak detector § UndefinedBehaviorSanitizer - a detector of undeﬁned behaviour o Later in the course, you might want to look up: § ThreadSanitizer - a data race detector Address Sanitizer o Address Sanitizer is a memory error detector for: § Out-of-bounds / Use-after-free / Double free memory accesses o Makes clang insert instructions to monitor every memory access o This slows down the execution by about 2x § valgrind (a similar tool) has often a slowdown of 20-100x! o These flags enable address sanitizer: clang -fsanitize=address -fno-omit-frame-pointer -O1 -g -Wall -Werror program.c -o program § fno-omit-frame-pointer produces a readable call stack § O1 enables basic optimizations o The compiler will produce a binary as usual: ./program o Address Sanitizer has found hundreds of bugs in large scale software projects § e.g. Chromium and Firefox Address Sanitizer output Reports a heap-use- after-free on address 0x614000000044 Provides information where the memory was freed (line 5) and allocated (line 4) Memory Sanitizer o Detects uninitialized reads to memory o Under active development o Currently only available for Linux and BSD #include <stdlib.h> #include <stdio.h> int main(int argc, char** argv) { int* a = malloc(sizeof(int)*10); a[5] = 0; if (a[argc]) printf(\"xx\\n\"); return 0; } % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc % ./a.out WARNING: MemorySanitizer: use-of-uninitialized-value #0 0x7f45944b418a in main umr.c:6 #1 0x7f45938b676c in __libc_start_main libc-start.c:226 Leak Sanitizer o Leak sanitizer detects memory leaks (i.e. un-free’d memory blocks) o Under active development o Available for Linux, macOS, NetBSD Undefined Behaviour o For certain operations, the C standard demands no particular behaviour § typically cases that are considered bugs, e.g. dereferencing a null pointer o It is expensive to check if dereferencing a pointer is valid every time o Because the compiler does not have to ensure a particular behaviour for null pointers, it assumes that the programmer checked that the pointer is not null o Undefined behaviour is therefore crucial for fast code, but makes detection of bugs much harder, as it is not guaranteed that a bug will result in a crash o A good introduction to undefined behaviour is this series of blog posts: What Every C Programmer Should Know About Undefined Behavior Undeﬁned Behaviour Sanitizer o Detects various types of undefined behaviour int main(int argc, char **argv) { int k = 0x7fffffff; // this is the largest possible signed int value ... k += argc; // ... this will produce an integer overflow return 0; } % clang -fsanitize=undefined -Wall -Werror intOverflow.c -o intOverflow % ./intOverflow intOverflow.c:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int' An integer overﬂow is detected","libVersion":"0.3.2","langs":""}