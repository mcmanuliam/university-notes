{"path":"software engineering/year 2/semester 2/Algorithmics/Slides/3. Graphs and Graph Algorithms/3.2 Weighted Graphs/3.2.1 Shortest path (Dijkstra's Algorithm).pdf","text":"Algorithmics Dr. Oana Andrei School of Computing Science University of Glasgow oana.andrei@glasgow.ac.uk Algorithmics 2025 Lecture 7 Section 3 – Graphs and graph algorithms Graph basics − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − breadth/depth first search Topological ordering Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) 2 Graphs - Recap An (undirected) graph G = (V,E) − V is finite set of vertices (the vertex set) − E is set of edges, each edge is a subset of V of size 2 (the edge set) − each edge is a set vertices of the form {u,v} A directed graph (digraph) G = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices 3 Weighted graphs - Recap Each edge e has a positive integer weight given by wt(e)>0 − graph may be undirected or directed − weight may represent length, cost, capacity, etc − if an edge is not part of the graph its weight is infinity 4 4 6 6 7 4 5 7 5 5 8 u v w yx z Spanning trees Spanning tree: − subgraph (subset of edges) which is both a tree and ‘spans’ every vertex − a spanning tree is obtained from a connected graph by deleting edges − the weight of a spanning tree is the sum of the weights of its edges Problem: for a weighted connected undirected graph, find a minimum weight spanning tree − this represents the ‘cheapest’ way of interconnecting the vertices Applications include: − design of networks for computer, telecommunications, transportation, gas, electricity, ... − clustering, approximating the travelling salesman problem 5 Weighted graphs – Example – Spanning tree Weighted graph G 6 4 6 6 7 4 5 7 5 5 8 spanning tree: subgraph which is both a tree and ‘spans’ every vertex 4 6 6 7 4 5 7 5 5 8 delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 7 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 8 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 9 4 6 6 7 4 5 7 5 5 8 6 7 4 5 7 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 10 4 6 6 7 4 5 7 5 5 8 6 7 4 5 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 11 4 6 6 7 4 5 7 5 5 8 6 7 5 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex cannot delete any more edges and we have a tree delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G Spanning tree for G − weight 28 12 4 6 6 7 4 5 7 5 5 8 6 7 5 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex Weighted graphs – Example – Spanning tree Weighted graph G 13 4 6 6 7 4 5 7 5 5 8 4 6 6 7 4 5 7 5 5 8 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 14 4 6 6 7 4 5 7 5 5 8 4 6 6 7 4 5 7 5 8 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 15 4 6 6 7 4 5 7 5 5 8 4 6 6 7 4 5 7 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 16 4 6 6 7 4 5 7 5 5 8 4 6 6 4 5 7 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 17 4 6 6 7 4 5 7 5 5 8 4 6 4 5 7 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G 18 4 6 6 7 4 5 7 5 5 8 4 6 4 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex cannot delete any more edges and we have a tree delete edges while still ‘spanning’ vertices Weighted graphs – Example – Spanning tree Weighted graph G Spanning tree for G − weight 24 19 4 6 6 7 4 5 7 5 5 8 4 6 4 5 5 spanning tree: subgraph which is both a tree and ‘spans’ every vertex Minimum weight spanning tree problem An example of a problem in combinatorial optimisation − find ‘best’ way of doing something among a (large) number of candidates − can always be solved, at least in theory, by exhaustive search (how?) − however this may be infeasible in practice − typically an exponential-time algorithm • e.g. Kn (clique of size n) has nn-2 spanning trees (Cayley’s formula) • recall: a graph is a clique if every pair vertices is joined by an edge − a much more efficient algorithm may be possible and is true in the case of minimum weight spanning trees 20 Minimum weight spanning tree problem An example of a problem in combinatorial optimisation − find ‘best’ way of doing something among a (large) number of candidates − can always be solved, at least in theory, by exhaustive search − however this may be infeasible − typically an exponential-time algorithm The Prim-Jarnik minimum spanning tree algorithm − an example of a greedy algorithm − it makes a sequence of decisions based on local optimality − and ends up with the globally optimal solution For many problems, greedy algorithms do not yield optimal solution − see examples later in the course 21 The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edges 22 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of the graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm – Example Weighted graph G 23 4 6 6 7 4 5 7 5 5 8 The Prim-Jarnik algorithm – Example Weighted graph G 24 4 6 6 7 4 5 7 5 5 8 tree vertices: u non-tree vertices: v,w,x,y,z 4 6 6 7 4 5 7 5 5 8 u v w yx z The Prim-Jarnik algorithm – Example Weighted graph G 25 4 6 6 7 4 5 7 5 5 8 tree vertices: u non-tree vertices: v,w,x,y,z 4 6 6 7 4 5 7 5 5 8 u v w yx z consider all tree vertex and non-tree vertex edges The Prim-Jarnik algorithm – Example Weighted graph G 26 4 6 6 7 4 5 7 5 5 8 tree vertices: u non-tree vertices: v,w,x,y,z 4 6 6 7 4 5 7 5 5 8 u v w yx z minimum such edge is {u,v} The Prim-Jarnik algorithm – Example Weighted graph G 27 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u w yx z make v a tree vertex & add edge to the tree 4 v tree vertices: u,v non-tree vertices: w,x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 28 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u w yx z 4 v consider all tree vertex and non-tree vertex edges tree vertices: u,v non-tree vertices: w,x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 29 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u w yx z minimum such edge is {v,w} 4 v tree vertices: u,v non-tree vertices: w,x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 30 4 6 6 7 4 5 7 5 5 8 4 could also have chosen {u,w} 6 6 7 4 5 7 5 5 8 u w yx z minimum such edge is {v,w} v tree vertices: u,v non-tree vertices: w,x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 31 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 make w a tree vertex & add edge to the tree tree vertices: u,v,w non-tree vertices: x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 32 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 consider all tree vertex and non-tree vertex edges tree vertices: u,v,w non-tree vertices: x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 33 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 minimum such edge is {w,y} tree vertices: u,v,w non-tree vertices: x,y,z The Prim-Jarnik algorithm – Example Weighted graph G 34 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 make y a tree vertex & add edge to the tree tree vertices: u,v,w,y non-tree vertices: x,z The Prim-Jarnik algorithm – Example Weighted graph G 35 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 consider all tree vertex and non-tree vertex edges tree vertices: u,v,w,y non-tree vertices: x,z The Prim-Jarnik algorithm – Example Weighted graph G 36 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 minimum such edge is {w,z} tree vertices: u,v,w,y non-tree vertices: x,z The Prim-Jarnik algorithm – Example Weighted graph G 37 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 make z a tree vertex & add edge to the tree tree vertices: u,v,w,y,z non-tree vertices: x The Prim-Jarnik algorithm – Example Weighted graph G 38 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 consider all tree vertex and non-tree vertex edges tree vertices: u,v,w,y,z non-tree vertices: x The Prim-Jarnik algorithm – Example Weighted graph G 39 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 minimum such edge is {x,v} tree vertices: u,v,w,y,z non-tree vertices: x The Prim-Jarnik algorithm – Example Weighted graph G 40 4 6 6 7 4 5 7 5 5 8 6 6 7 4 5 7 5 5 8 u v w yx z 4 make x a tree vertex & add edge to the tree tree vertices: u,v,w,x,y,z non-tree vertices: The Prim-Jarnik algorithm – Example Weighted graph G Minimum spanning tree for G − weight 24 41 4 6 6 7 4 5 7 5 5 8 6 4 5 5 u v w yx z 4 The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge 42 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) 43 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) − initialisation O(n) (n operations to set vertices to be tv or ntv) 44 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) − initialisation O(n) (n operations to set vertices to be tv or ntv) − the outer loop is executed n-1 times − initially n-1 ntv vertices and each iteration turns one ntv to a tv 45 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) − initialisation O(n) (n operations to set vertices to be tv or ntv) − the outer loop is executed n-1 times − the inner loop checks all edges from a tree-vertex to a non-tree-vertex − there can be O(n2) of these 46 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) − initialisation O(n) (n operations to set vertices to be tv or ntv) − the outer loop is executed n-1 times − the inner loop O(n2) − updating tree O(1) each iteration 47 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) − initialisation O(n) (n operations to set vertices to be tv or ntv) − the outer loop is executed n-1 times − the inner loop O(n2) and updating tree O(1) each iteration − so overall the algorithm is O(n) + O(n3) = O(n3) 48 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } Section 3 – Graphs and graph algorithms Graph basics − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − breadth/depth first search Topological ordering Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) 49 The Prim-Jarnik algorithm Min spanning tree is constructed by choosing a sequence of edge Analysis (n is the number of vertices) − initialisation O(n) (n operations to set vertices to be tv or ntv) − the outer loop is executed n-1 times − the inner loop O(n2) and updating tree O(1) each iteration (!) − so overall the algorithm is O(n) + O(n3) = O(n3) 50 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); while (number of ntv > 0){ find edge e = {p,q} of graph such that p is a tv; q is an ntv; wt(e) is minimised over such edges; adjoin edge e to the (spanning) tree; make q a tv; } Dijkstra’s refinement Introduce an attribute bestTV for each non-tree vertex (ntv) q − bestTV is set to the tree vertex (tv) p for which wt({p,q}) is minimised 51 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update bestTV as tree vertices have changed } Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 52 4 6 6 7 4 5 7 5 5 8 u v w yx z tree vertices: z non-tree vertices: u,v,w,x,y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 53 4 6 6 7 4 5 7 5 5 8 u v w yx z tree vertices: z non-tree vertices: u,v,w,x,y q q.bestTV wt({q.bestTV,q}) u z ∞ v z ∞ w z 5 x z 6 y z 7 z - - initialise bestTV to the only tv z Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 54 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z ∞ v z ∞ w z 5 x z 6 y z 7 z - - tree vertices: z non-tree vertices: u,v,w,x,y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 55 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z ∞ v z ∞ w z 5 x z 6 y z 7 z - - tree vertices: z non-tree vertices: u,v,w,x,y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 56 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z ∞ v z ∞ w z 5 x z 6 y z 7 z - - tree vertices: w,z non-tree vertices: u,v,x,y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 57 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z➝w ∞➝5 v z➝w ∞➝5 w - - x z 6 y z➝w 7➝4 z - - tree vertices: w,z non-tree vertices: u,v,x,y check bestTV against new tv vertex w Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 58 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z➝w ∞➝5 v z➝w ∞➝5 w - - x z 6 y z➝w 7➝4 z - - tree vertices: w,z non-tree vertices: u,v,x,y check bestTV against new tv vertex w Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 59 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z➝w ∞➝5 v z➝w ∞➝5 w - - x z 6 y z➝w 7➝4 z - - tree vertices: w,z non-tree vertices: u,v,x,y check bestTV against new tv vertex w Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 60 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u z➝w ∞➝5 v z➝w ∞➝5 w - - x z 6 y z➝w 7➝4 z - - tree vertices: w,z non-tree vertices: u,v,x,y check bestTV against new tv vertex w Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 61 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y w 4 z - - tree vertices: w,z non-tree vertices: u,v,x,y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 62 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y w 4 z - - tree vertices: w,z non-tree vertices: u,v,x,y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 63 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y w 4 z - - tree vertices: w,y,z non-tree vertices: u,v,x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 64 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y - - z - - tree vertices: w,y,z non-tree vertices: u,v,x check bestTV against new tv vertex y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 65 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y - - z - - tree vertices: w,y,z non-tree vertices: u,v,x check bestTV against new tv vertex y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 66 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y - - z - - tree vertices: w,y,z non-tree vertices: u,v,x check bestTV against new tv vertex y Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 67 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y - - z - - tree vertices: w,y,z non-tree vertices: u,v,x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 68 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y - - z - - tree vertices: w,y,z non-tree vertices: u,v,x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 69 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w 5 v w 5 w - - x z 6 y - - z - - tree vertices: v,w,y,z non-tree vertices: u,x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 70 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w➝v 5➝4 v - - w - - x z 6 y - - z - - tree vertices: v,w,y,z non-tree vertices: u,x check bestTV against new tv vertex v Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 71 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w➝v 5➝4 v - - w - - x z 6 y - - z - - tree vertices: v,w,y,z non-tree vertices: u,x check bestTV against new tv vertex v Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 72 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u w➝v 5➝4 v - - w - - x z 6 y - - z - - tree vertices: v,w,y,z non-tree vertices: u,x check bestTV against new tv vertex v Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s Dijkstra’s refinement - Example 73 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u v 4 v - - w - - x z 6 y - - z - - tree vertices: v,w,y,z non-tree vertices: u,x Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s Dijkstra’s refinement - Example 74 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u v 4 v - - w - - x z 6 y - - z - - tree vertices: v,w,y,z non-tree vertices: u,x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 75 q q.bestTV wt({q.bestTV,q}) u v 4 v - - w - - x z 6 y - - z - - 4 6 6 7 4 5 7 5 5 8 u v w yx z tree vertices: u,v,w,y,z non-tree vertices: x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 76 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u - - v - - w - - x z 6 y - - z - - tree vertices: u,v,w,y,z non-tree vertices: x check bestTV against new tv vertex u Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s Dijkstra’s refinement - Example 77 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u - - v - - w - - x z 6 y - - z - - tree vertices: u,v,w,y,z non-tree vertices: x Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s Dijkstra’s refinement - Example 78 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u - - v - - w - - x z 6 y - - z - - tree vertices: u,v,w,y,z non-tree vertices: x Dijkstra’s refinement - Example Weighted graph G − choose ntv q for which wt({q, q.bestTV}) is minimal and make q a tv − update s.bestTV for all ntv s 79 4 6 6 7 4 5 7 5 5 8 u v w yx zq q.bestTV wt({q.bestTV,q}) u - - v - - w - - x - - y - - z - - tree vertices: u,v,w,x,y,z non-tree vertices: Dijkstra’s refinement - Example Weighted graph G Minimum spanning tree for G − weight 24 80 4 6 4 5 5 u v w yx zq q.bestTV wt({q.bestTV,q}) u - - v - - w - - x - - y - - z - - Dijkstra’s refinement Introduce an attribute bestTV for each non-tree vertex (ntv) q − bestTV is set to the tree vertex (tv) p for which wt({p,q}) is minimised 81 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update bestTV as tree vertices have changed } Dijkstra’s refinement – Analysis − initialisation is O(n) 82 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update as tvs have changed } Dijkstra’s refinement – Analysis − initialisation is O(n) − while loop is executed n-1 times 83 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update as tvs have changed } Dijkstra’s refinement – Analysis − initialisation is O(n) − while loop is executed n-1 times − first part takes O(n) • O(n) to find minimal ntv and O(1) to adjoin and update 84 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update as tvs have changed } Dijkstra’s refinement – Analysis − initialisation is O(n) − while loop is executed n-1 times − first part takes O(n) and second part takes O(n) • for each ntv s only need to compare weights for s.bestTV and new tv vertex (i.e. q) to update the value of s.bestTV 85 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update as tvs have changed } Dijkstra’s refinement – Analysis − initialisation is O(n) − while loop is executed n-1 times • first and second parts each take O(n) so for both parts O(n)+O(n) = O(n) − overall the algorithm is O(n) + O(n2) = O(n2) • while Prim-Jarnik is O(n3) 86 set an arbitrary vertex r to be a tree-vertex (tv); set all other vertices to be non-tree-vertices (ntv); for (each ntv s) set s.bestTV = r; // r is the only tv while (number of ntv > 0){ find ntv q for which wt({q, q.bestTV}) is minimal; adjoin {q, q.bestTV} to the tree; make q a tv; for (each ntv s) update s.bestTV; // update as tvs have changed } Plan for next week In class test on Monday − 1h30 class test, additional time 15 min to deal with submission, plus 30 minutes for those entitled to additional time − online, word document to fill in your answers and upload − open book assessment − 3 questions: 2 on algorithms tracing and one on describing an algorithm to solve a problem (based on some algorithms covered in weeks 1 & 2) The assessed exercise will be released on Tuesday - based on graph theory - ask for help re: the AE during any subsequent tutorial session - two lab sessions 2h each to prepare for and help with the AE - Wednesday 19 March with a lab exercise to get you going - Wednesday 26 March dedicated for working on the AE and ask for help 87 Quiz week 2 and mid-way feedback The quiz for week 2 opens on Wednesday 12 March at 12:00 − 5 questions − time limit 1 − closes on Friday at 22:00 Mid-way feedback opens on Wednesday 12 March at 11:00 − remains open until Wednesday 19 March 13:00 88 Outline of course Section 0: Quick recap on algorithm analysis Section 1: Sorting algorithms Section 2: Strings and text algorithms Section 3: Graphs and graph algorithms Section 4: An introduction to NP completeness Section 5: A (very) brief introduction to computability 89","libVersion":"0.3.2","langs":""}