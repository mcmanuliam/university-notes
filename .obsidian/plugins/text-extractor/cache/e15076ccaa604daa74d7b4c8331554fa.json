{"path":"Year 2/Practical Algorithms/slides/10. Hashmaps.pdf","text":"Practical Algorithms Yiannis Giannakopoulos (with thanks to Michele Sevegnani) School of Computing Science University of Glasgow Practical Algorithms 2024 Maps & Hash Tables 2PA, 2024 The Map ADT Dictionaries: Motivation â€¢ Many real-life data sets consist of (key,value) entries â€¢ Examples: âˆ’ (URL, IP address) âˆ’ (student ID, grade) â€¢ Abstraction of a (partial) function: 3PA, 2024 (â€œuniverseâ€ of) keys values www.glasgow.ac.uk â˜ 130.209.16.93 The Map ADT â€¢ A map models a dynamic and searchable collection of (key,value) pairs (called entries or elements) âˆ’ Other names: associative array, dictionary, symbol table, â€¦ âˆ’ Multiple entries with the same key are not allowed (keys must be unique) â€¢ Main map operations âˆ’ INSERT(M,k,v): add an entry (k,v) to map M âˆ’ DELETE(M,k): remove the entry with key k from map M (return NIL if it does not exist) âˆ’ SEARCH(M,k): return the value v of the entry with key k in map M (return NIL if it does not exist) â€¢ Auxiliary map operation âˆ’ IS-EMPTY(M): test whether M contains no entries (returns a Boolean value) 4PA, 2024 Example: ASCII â€¢ ASCII character encoding (128 entries) âˆ’ keys: integers {0,1,â€¦,127}, values: characters 5PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) âˆ’ INSERT(M, 71, â€˜Gâ€™) âˆ’ INSERT(M, 113, â€˜qâ€™) âˆ’ INSERT(M, 109, â€˜mâ€™) âˆ’ SEARCH(M, 65) âˆ’ INSERT(M, 83, â€˜Sâ€™) âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 6PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) âˆ’ INSERT(M, 113, â€˜qâ€™) âˆ’ INSERT(M, 109, â€˜mâ€™) âˆ’ SEARCH(M, 65) âˆ’ INSERT(M, 83, â€˜Sâ€™) âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 7PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) âˆ’ INSERT(M, 109, â€˜mâ€™) âˆ’ SEARCH(M, 65) âˆ’ INSERT(M, 83, â€˜Sâ€™) âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 8PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™)} âˆ’ INSERT(M, 109, â€˜mâ€™) âˆ’ SEARCH(M, 65) âˆ’ INSERT(M, 83, â€˜Sâ€™) âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 9PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™)} âˆ’ INSERT(M, 109, â€˜mâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™)} âˆ’ SEARCH(M, 65) âˆ’ INSERT(M, 83, â€˜Sâ€™) âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 10PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™)} âˆ’ INSERT(M, 109, â€˜mâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™)} âˆ’ SEARCH(M, 65) return: â€˜Aâ€™ âˆ’ INSERT(M, 83, â€˜Sâ€™) âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 11PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™)} âˆ’ INSERT(M, 109, â€˜mâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™)} âˆ’ SEARCH(M, 65) return (65, â€˜Aâ€™) âˆ’ INSERT(M, 83, â€˜Sâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™), (83, â€˜Sâ€™)} âˆ’ DELETE(M, 113) âˆ’ SEARCH(M, 113) 12PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™)} âˆ’ INSERT(M, 109, â€˜mâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™)} âˆ’ SEARCH(M, 65) return (65, â€˜Aâ€™) âˆ’ INSERT(M, 83, â€˜Sâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™), (83, â€˜Sâ€™)} âˆ’ DELETE(M, 113) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (109, â€˜mâ€™), (83, â€˜Sâ€™)} âˆ’ SEARCH(M, 113) 13PA, 2024 Example: ASCII M = {} âˆ’ INSERT(M, 65, â€˜Aâ€™) M = {(65, â€˜Aâ€™)} âˆ’ INSERT(M, 71, â€˜Gâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™)} âˆ’ INSERT(M, 113, â€˜qâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™)} âˆ’ INSERT(M, 109, â€˜mâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™)} âˆ’ SEARCH(M, 65) return (65, â€˜Aâ€™) âˆ’ INSERT(M, 83, â€˜Sâ€™) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™), (83, â€˜Sâ€™)} âˆ’ DELETE(M, 113) M = {(65, â€˜Aâ€™), (71, â€˜Gâ€™), (109, â€˜mâ€™), (83, â€˜Sâ€™)} âˆ’ SEARCH(M, 113) return NIL 14PA, 2024 Map Implementations What is the â€œbestâ€ way to implement such a data structure? 15PA, 2024 â€¢ We can implement a map using a doubly-linked list: âˆ’ Values are stored as satellite data (attribute if small, pointer for larger structures) â€¢ Performance âˆ’ INSERT takes O(1) time (O(n) if we first check for duplicates) âˆ’ SEARCH and DELETE take O(n) â€“ we need to traverse the entire list to look for an entry â€¢ The list-based implementation is recommended only for maps of small size â€¢ Can we do better? List-based Implementation 16PA, 2024 satellite data - pointer M.head 65 A 71 G 113 qkey value Tree-based Implementation â€¢ Using a self-balancing trees we can guarantee a worst-case running time of: âˆ’ O(log n) for all the main map ADT operations â€¢ Additionally, an in-order traversal allows us to get a sorted sequence of all the pairs stored in the map â€¢ Can we do even better? 17PA, 2024 A65 G71 m109 q113 key value satellite data - attribute Direct-address Tables â€¢ Assumptions âˆ’ Each element of our map M has an integer key drawn from the universe U = {0,1,â€¦, m â€“ 1} âˆ’ Recall: no two elements have the same key â€¢ Î‘ direct-address table is an array T[0,..,m - 1] that can represent map M in the following way: âˆ’ Each position (also called slot or bucket) in T corresponds to a key in the universe U âˆ’ Slot k contains/points to the value of the element M with key k â€¢ In other words: if (k,v)âˆˆM then T[k]=v. âˆ’ If no element has key k, then T[k] = NIL 18PA, 2024 T A G m q â€¦ slot 65 â€¦ 70 71 â€¦ 109 110 111 112 113 â€¦ 127 1 0 key value NIL Direct-address Table: Map Implementation â€¢ Operations are trivial to implement âˆ’ Each operation takes O(1) time â€¢ However, what if: 1. The keys are not natural numbers? 2. The universe U is much larger than the â€œactualâ€ number of keys that we are expecting to use, i.e |U| â‰« m ? â€¢ Hashing deals with issues 1. and 2. by: 1. Encoding 2. Compression 19PA, 2024 DIRECT-ADDRESS-INSERT(T,x) T[x.key] = x.value DIRECT-ADDRESS-SEARCH(T,k) return T[k] DIRECT-ADDRESS-DELETE(T,k) T[k] = NIL element x = (key,value) 20PA, 2024 Hash Tables Hashing: Overview 21PA, 2024 hash code compression hash table T 0 1 2 m-1 universe U keys natural numbers values hash function The Hash Table Data Structure â€¢ Generalizes direct-address tables by adding a hash function â€¢ Consists of: 1. An array T[0,..,m - 1] of fixed size m (called hash table or bucket array) 2. A hash function h: U â†’ {0,1,â€¦,m - 1} mapping keys to slots of T â€¢ Hash collision: when two keys are mapped to the same slot of the hash table âˆ’ That is, h(k1)=h(k2) for k1â‰ k2 (where k1,k2 âˆˆ U) âˆ’ In general, hash collisions are unavoidable (if |U| > m) âˆ’ However: a â€œgoodâ€ hash function spreads keys as â€œevenlyâ€ as possible over the slots of T â¢ Each backet should be used with equal probability for data randomly sampled from the universe U â€¢ Additionally: hash functions should be â€œsimpleâ€ and fast to compute â€¢ Under the above assumptions: hash tables support INSERT, DELETE and SEARCH operations in O(1) time â€œon averageâ€ 22PA, 2024 Example: ASCII â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,1,â€¦,127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) in hash table T 23PA, 2024 Tindex 1 0 6 7 5 4 3 2 Example: ASCII â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,1,â€¦,127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) 24PA, 2024 A65 Tindex 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, (65, â€˜Aâ€™)) âˆ’ h(65) = 65 mod 8 = 1 âˆ’ Insert element in slot 1 Example â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,â€¦127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) 25PA, 2024 A65 Tindex 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, (71, â€˜Gâ€™)) âˆ’ h(71) = 71 mod 8 = 7 âˆ’ Insert element in slot 7 G71 Example â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,â€¦127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) 26PA, 2024 A65 Tindex 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, (113, â€˜qâ€™)) âˆ’ h(113) = 113 mod 8 = 1 âˆ’ Insert element in slot 1, but slot 1 is already occupied âˆ’ We say that keys 65 and 113 collide G71 Example â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,â€¦127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) 27PA, 2024 q113 Tindex 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, (113, â€˜qâ€™)) âˆ’ h(113) = 113 mod 8 = 1 âˆ’ A (bad, in general) strategy to resolve collisions is to store only the most recent key/value âˆ’ We will study more sophisticated strategies to resolve collisions later in these lectures G71 Example â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,â€¦127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) 28PA, 2024 q113 Tindex 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, (109, â€˜mâ€™)) âˆ’ h(109) = 109 mod 8 = 5 âˆ’ Insert element in slot 5 G71 m109 Example â€¢ ASCII table with hash function h(k) = k mod 8 âˆ’ U = {0,â€¦127} and size of hash table T is m = 8 â€¢ Insert (65, â€˜Aâ€™), (71, â€˜Gâ€™), (113, â€˜qâ€™), (109, â€˜mâ€™) and (83, â€˜Sâ€™) 29PA, 2024 q113 Tindex 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, (83, â€˜Sâ€™)) âˆ’ h(83) = 83 mod 8 = 3 âˆ’ Insert element in slot 3 G71 m109 S83 30PA, 2024 Encoding Encoding general keys as natural numbers â€¢ Most hash functions operate on natural numbers, ie they assume as a universe of keys U = â„• â€¢ There are several methods (called hash codes) to convert/encode an arbitrary object as a natural number, e.g. âˆ’ Integer casting âˆ’ Component sum âˆ’ Memory address âˆ’ Polynomial hashing â€¢ Here we will only describe integer casting and component sum here, very briefly. 31PA, 2024 Integer Casting â€¢ Most data types have a â€œnaturalâ€ bit representation, in every programming language â€¢ So, we can use as key the integer corresponding to that binary number â€¢ Example: 100112 = 1910 â€¢ For example: Python uses 64-bit values to encode many fundamental types, e.g. float and int â€¢ So, integer casting can be readily used for types: â€¢ For longer types, e.g. strings, we need to perform some kind of â€œmergingâ€ â€¢ For example, an object (ğ’™ğŸ, ğ’™ğŸ, â€¦ , ğ’™ğ’âˆ’ğŸ) where all ğ’™ğ’Š are 64-bit integers can be represented as o Ïƒğ‘–=0 ğ‘›âˆ’1 ğ‘¥ğ‘–, or o ğ‘¥0â¨ ğ‘¥1 â¨ â‹¯ â¨ ğ‘¥ğ‘›âˆ’1, where â¨ is the XOR operator â¢ This is known as component sum hashing 32PA, 2024 36PA, 2024 Compression: Hash Functions â„• âŸ¶ {0,1, â€¦ , ğ‘š âˆ’ 1} Truncation â€¢ Take the first/last few digits of the key âˆ’ Problem: it may generate many collisions if there are regularities in the input keys â€¢ Example âˆ’ Student IDs consisting of 8 digits: 2023 1734 âˆ’ Numbers are assigned sequentially âˆ’ Students in a given class/year will tend to have IDs close together, and all beginning with the same first few digits âˆ’ But: taking the last three digits will work a lot better! 37PA, 2024 Division â€¢ Map a key k into one of m slots by taking the remainder of the division of k by m âˆ’ The hash function is h(k) = k mod m â¢ Python: k % m â€¢ Good practice: to ensure that data is distributed fairly, we usually choose the table size m to be âˆ’ Prime âˆ’ Not â€œtoo closeâ€ to an exact power of 2 â€¢ If m = 2p, then h(k) is just the p lowest-order bits of k â–ª Examples: 1010112 % 102 = 12, 1010112 % 1002 = 112 â–ª The analogous case for decimal numbers would be division by powers of 10: 23410 % 1010 = 410, 23410 % 10010 = 3410 â€¢ If use of lower-order bits is suitable, better to simply truncate 38PA, 2024 Example: Hashing by Division â€¢ Suppose we want to allocate a hash table to hold roughly 5000 keys â€¢ We pick m to be a prime close to 5000 but not near any power of 2 âˆ’ 212 = 4069 âˆ’ 213 = 8192 â€¢ Primes near 5000: âˆ’ 4987, 4993, 4999, 5003, 5009, 5011 â€¢ So, our hash function could be h(k) = k mod 5003 39PA, 2024 41PA, 2024 Collision Resolution 42PA, 2024 Chaining Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 43PA, 2024 T 2 slot 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 44PA, 2024 T 2 slot 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 45PA, 2024 T 2 slot 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 46PA, 2024 G71 K75 T 2 slot 3 4 5 6 7 8 1 0 key value z122 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 47PA, 2024 G71 K75 T 2 3 4 5 6 7 8 1 0 z122 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 slot Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 48PA, 2024 G71 K75 T 2 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 %37 z122 slot Collision Resolution by Chaining â€¢ Each slot of the hash table points to its own (doubly) linked list (called chain) â€¢ All elements that hash to the same slot are stored in that slotâ€™s list âˆ’ List T[i] holds elements (k,v) for which h(k)=i, i=0,1,â€¦,m-1 â€¢ Example: ASCII with m=9 â€¢ U = {0, â€¦,127} â€¢ Insert key sequence: 122, 71, 75, 37, 65, 109 â€¢ Assume that we use a hash function h: U â†’ {0,â€¦,8} such that: 49PA, 2024 A65 G71 m109 K75 T 2 3 4 5 6 7 8 1 0 %37 z122 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 slot 59PA, 2024 Open-Address Hashing Collision Resolution by Open Addressing â€¢ General scheme: if a collision occurs, an alternative cell is tried (or â€œprobedâ€) until an empty cell is found âˆ’ Appropriate when memory availability is limited, and we cannot use auxiliary data structures (like linked lists in chaining) âˆ’ The load factor needs to be at most Î±â‰¤ 1: otherwise, we may overflow the hash table â€¢ Rigorously, open addressing can be modelled by adding an extra parameter to our hash function: h: U Ã— {0,1,â€¦,m-1} â†’ {0,1,â€¦,m-1} where h(k,i) gives the slot that we should probe at our i-th try. âˆ’ Implicit assumption: each key should probe all slots âˆ’ Formally, this means that ( h(k,0), h(k,1), â€¦, h(k,m-1) ) is a permutation of (0, 1,â€¦, m-1), for all kâˆˆU 60PA, 2024 Open Addressing: Insertion â€¢ For a given hash function h(k,i), the HASH-INSERT procedure takes as input a hash table T and a key k and âˆ’ Returns the slot number where it stores k, or âˆ’ Raises an error because T is already full 61PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error â€œhash table overflowâ€ Example: Linear Probing â€¢ Hashing by division into a table of size m=8 â€¢ Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) âˆ’ i.e. h(k,i) = (k+i) mod 8 62PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error â€œhash table overflowâ€ 113 Tslot 1 0 6 7 5 4 3 2 71 109 83 Example: Linear Probing â€¢ Hashing by division into a table of size m=8 â€¢ Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) âˆ’ i.e. h(k,i) = (k+i) mod 8 63PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = (k+i) % m if T[j] == NIL T[j] = k return j else i = i + 1 error â€œhash table overflowâ€ 113 Tslot 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, 65) âˆ’ h(65) = 65 mod 8 = 1 âˆ’ Collision 71 109 83 Example: Insertion â€¢ Hashing by division into a table of size m=8 â€¢ Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) âˆ’ i.e. h(k,i) = (k+i) mod 8 64PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error â€œhash table overflowâ€ 113 Tslot 1 0 6 7 5 4 3 2 71 109 83 65 âˆ’ INSERT(T, 65) âˆ’ h(65) = 65 mod 8 = 1 âˆ’ Insert element in slot 2 Example: Insertion â€¢ Hashing by division into a table of size m=8 â€¢ Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) âˆ’ i.e. h(k,i) = (k+i) mod 8 65PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error â€œhash table overflowâ€ 113 Tslot 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, 57) âˆ’ h(57) = 57 mod 8 = 1 âˆ’ Collision 71 109 83 65 Example: Insertion â€¢ Hashing by division into a table of size m=8 â€¢ Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) âˆ’ i.e. h(k,i) = (k+i) mod 8 66PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error â€œhash table overflowâ€ 113 Tslot 1 0 6 7 5 4 3 2 âˆ’ INSERT(T, 57) âˆ’ h(57) = 57 mod 8 = 1 âˆ’ Insert element in slot 4 57 71 109 83 65 Hashing: Further Reading â€œIntroduction to Algorithmsâ€ (4th edition) by Cormen, Leiserson, Rivest, and Stein Chapter 11 â€œAlgorithms Illuminatedâ€ (Omnibus edition) by Roughgarden Chapter 12 PA, 2024 67","libVersion":"0.3.2","langs":""}