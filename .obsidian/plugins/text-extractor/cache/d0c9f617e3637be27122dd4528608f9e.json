{"path":"software engineering/year 2/semester 2/Algorithmics/Slides/4. NP Completeness/GAAlgs_lect09_np2.pdf","text":"Algorithmics Dr. Oana Andrei School of Computing Science University of Glasgow oana.andrei@glasgow.ac.uk Algorithmics 2025 Lecture 9 Section 4 – NP-completeness Introduction (examples and discussion) NP-complete problems The classes P and NP Polynomial-time reductions Formal definition of NP-completeness How to prove a problem is NP-complete 2 The class P P is the class of all decision problems that can be solved in polynomial time Fortunately, many problems are in P − is there a path of length ≤K from vertex u to vertex v in a graph G? − is there a spanning tree of weight ≤K in a graph G? − is a graph G bipartite? − is a graph G connected? − deadlock detection: does a directed graph D contain a cycle? − text searching: does a text t contain an occurrence of a string s? − string distance: is d(s,t)≤K for strings s and t? − … P often extended to include search and optimisation problems - what is the minimum length path between vertex u and vertex v 3 The class NP The decision problems solvable in non-deterministic polynomial time − a non-deterministic algorithm can make non-deterministic choices • the algorithm is allowed to guess (so when run can give different answers) − hence is apparently more powerful than a normal deterministic algorithm P is certainly contained within NP − a deterministic algorithm is just a special case of a non-deterministic one But is that containment strict? − there is no problem known to be in NP and known not to be in P The relationship between P and NP is the most notorious unsolved question in computing science − there is a million dollar prize if you can solve this question 4 Non-deterministic algorithms (NDAs) Such an algorithm has an extra operation: non-deterministic choice − an NDA has many possible executions depending on values returned An NDA “solves” a decision problem Π if − for a ‘yes’-instance I of Π there is some execution that returns ’yes’ − for a ‘no’-instance I of Π there is no execution that returns ’yes’ and “solves” a decision problem Π in polynomial time if − for every ‘yes’-instance I of Π there is some execution that returns ‘yes’ which uses a number of steps bounded by a polynomial in the input − for a ‘no’-instance I of Π there is no execution that returns ’yes’ 5 int nonDeterministicChoice(int n) // returns a positive integer chosen from the range 1,…,n Non-deterministic algorithms (NDAs) An NDA “solves” a decision problem Π if − for a ‘yes’-instance I of Π there is some execution that returns ’yes’ − for a ‘no’-instance I of Π there is no execution that returns ’yes’ Clearly such algorithms are not useful in practice − who would use an algorithm that sometimes gives the right answer However they are a useful mathematical concept for defining the classes of NP and NP-complete problems 6 Non-deterministic algorithms - Example Graph colouring 7 // return true if graph g is k-colourable and false otherwise boolean nDGC(Graph g, int k){ for (each vertex v in g) v.setColour(nonDeterministicChoice(k)); for (each edge {u,v} in g) if (u.getColour() == v.getColour()) return false; return true; } “guess” a colour for each vertex“verify” the colouring Non-deterministic algorithms An non-deterministic algorithm can be viewed as − a guessing stage (non-deterministic) − a checking stage (deterministic and polynomial time) 8 start guess a ’certificate’ verify the certificate stop non-deterministic algorithm polynomial time algorithm Section 4 – NP-completeness Introduction (examples and discussion) NP-complete problems The classes P and NP Polynomial-time reductions Formal definition of NP-completeness How to prove a problem is NP-complete 9 Polynomial time reductions A polynomial-time reduction (PTR) is a mapping f from a decision problem Π1 to a decision problem Π2 such that: for every instance I1 of Π1 we have − the instance f(I1) of Π2 can be constructed in polynomial time − f(I1) is a ’yes’-instance of Π2 if and only if I1 is a ’yes’-instance of Π1 We write Π1 ∝ Π2 as an abbreviation for: there is a polynomial-time reduction from Π1 to Π2 10 Polynomial time reductions - Properties Transitivity: Π1 ∝ Π2 and Π2 ∝ Π3 implies that Π1 ∝ Π3 Since Π1 ∝ Π2 and Π2 ∝ Π3 we have − a PTR f from Π1 to Π2 − a PTR g from Π2 to Π3 Now for any instance I1 of Π1 since f is PTR we have − I2=f(I1) is an instance of Π2 that can be constructed in polynomial time − I2 has the same answer as I1 and since g is a PTR we have − I3=g(I2) is an instance of Π3 that can be constructed in polynomial time − I3 has the same answer as I2 11 Polynomial time reductions - Properties Transitivity: Π1 ∝ Π2 and Π2 ∝ Π3 implies that Π1 ∝ Π3 Since Π1 ∝ Π2 and Π2 ∝ Π3 we have − a PTR f from Π1 to Π2 − a PTR g from Π2 to Π3 Putting the results together: for any instance I1 of Π1 − I3=g(f(I1)) is an instance of Π3 constructed in polynomial time − I3 has the same answer as I1 − i.e. the composition of f and g is a PTR from from Π1 to Π3 12 Polynomial time reductions - Properties Relevance to P: Π1 ∝ Π2 and Π2∈P implies that Π1∈P − to solve an instance of Π1, reduce it to an instance of Π2 − roughly speaking, Π1 ∝ Π2 means that Π1 is ‘no harder’ than Π2 i.e. if we can solve Π2, then we can solve Π1 without much more effort • just need to additional perform a polynomial time reduction − but maybe that Π2 is harder to solve than Π1 • we only map to easy to solve instances of Π2 13 Polynomial time reductions - Example Reducing Hamiltonian cycle problem to travelling salesperson problem Hamiltonian Cycle Problem (HC) − instance: a graph G − question: does G contain a cycle that visits each vertex exactly once? Travelling Salesperson Decision Problem (TSDP) − instance: a set of n cities and integer distance d(i,j) between each pair of cities i,j, and a target integer K − question: is there a permutation p of {1,2,…,n} such that d(p1,p2) + d(p2,p3) + … + d(pn-1,pn) + d(pn,p1) ≤ K ? • i.e. is there a ’travelling salesperson tour’ of length ≤K 14 10 5 9 9 6 9 c2 c1 c4 c3 Polynomial time reductions - Example Reducing Hamiltonian cycle problem to travelling salesperson problem − G = (V,E) is an instance of HC − construct TSDP instance f(G) where • cities = V 15 a b ce d G a b ce d f(G) Polynomial time reductions - Example Reducing Hamiltonian cycle problem to travelling salesperson problem − G = (V,E) is an instance of HC − construct TSDP instance f(G) where • cities = V • d(u,v)=1 if {u,v}∈E (is an edge of G) 16 a b ce d G a b ce d f(G) 1 1 1 1 1 1 1 Polynomial time reductions - Example Reducing Hamiltonian cycle problem to travelling salesperson problem − G = (V,E) is an instance of HC − construct TSDP instance f(G) where • cities = V • d(u,v)=1 if {u,v}∈E and 2 otherwise (is not an edge of G) 17 a b ce d G a b ce d f(G) 1 1 1 1 1 1 1 2 2 2 Polynomial time reductions - Example Reducing Hamiltonian cycle problem to travelling salesperson problem − G = (V,E) is an instance of HC − construct TSDP instance f(G) where • cities = V • d(u,v)=1 if {u,v}∈E and 2 otherwise (is not an edge of G) • K = |V| 18 a b ce d G a b ce d f(G) 1 1 1 1 1 1 1 2 2 2 Polynomial time reductions - Example Reducing Hamiltonian cycle problem to travelling salesperson problem − G = (V,E) is an instance of HC − construct TSDP instance f(G) − f(G) can be constructed in polynomial time − f(G) has a tour of length ≤|V| if and only if G has a Hamiltonian cycle (tour includes |V| edges so cannot take any of the edges with weight 2) − therefore TSDP∈P implies that HC∈P − equivalently HC∉P implies that TSDP∉P (contrapositive) 19 a b ce d G a b ce d f(G) 1 1 1 1 1 1 1 2 2 2 Section 4 – NP-completeness Introduction (examples and discussion) NP-complete problems The classes P and NP Polynomial-time reductions Formal definition of NP-completeness How to prove a problem is NP-complete 20 NP-completeness A decision problem Π is NP-complete if 1. Π∈NP 2. for every problem Π' in NP: Π' is polynomial-time reducible to Π Consequences of definition − if Π is NP-complete and can show that Π∈P, then P = NP − every problem in NP can be solved in polynomial time by reduction to Π − supposing P ≠ NP, if Π is NP-complete, then Π∉P The structure of NP if P ≠ NP 21 P NP-complete NP NP hard problems An NP-complete problem is as hard as the hardest problems in NP A problem is NP-hard if every problem in NP can be reduced to it in polynomial time. − no requirement that the problem itself must be in NP − NP-hard problem is at least as hard as the hardest problems in NP, but it might not necessarily be in NP − it may not be possible to verify a solution in polynomial time for an NP- hard problem All NP-complete problems are NP-hard, but not all NP-hard problems are NP-complete 22 NP hard problems All NP-complete problems are NP-hard, but not all NP-hard problems are NP-complete − NP-complete problems are solvable in polynomial time by a nondeterministic Turing machine and have polynomial-time verifiable solutions − NP-hard problems encompass a broader category that includes problems for which verifying a solution might not be feasible in polynomial time NP-completeness mainly applies to decision problems − problems with a yes/no answer NP-hardness applies more broadly to decision problems, optimization problems, and search problems 23 Section 4 – NP-completeness Introduction (examples and discussion) NP-complete problems The classes P and NP Polynomial-time reductions Formal definition of NP-completeness How to prove a problem is NP-complete 24 Proving NP-completeness A decision problem Π is NP-complete if 1. Π∈NP 2. for every problem Π' in NP: Π' is polynomial-time reducible to Π How can we possibly prove any problem to be NP-complete? − it is not feasible to describe a reduction from every problem in NP − however, suppose we knew just one NP-complete problem Π1 To prove Π2 is NP-complete enough to show − Π2 is in NP − there exists a polynomial-time reduction from Π1 to Π2 25 Proving NP-completeness A decision problem Π is NP-complete if 1. Π∈NP 2. for every problem Π' in NP: Π' is polynomial-time reducible to Π Suppose we knew just one NP-complete problem Π1, then to prove Π2 is NP-complete it is enough to show − Π2 is in NP − there exists a polynomial-time reduction from Π1 to Π2 Correctness of the approach − for any Π∈NP, since Π1 is NP-complete we have Π ∝ Π1 − since Π ∝ Π1, Π1 ∝ Π2 and ∝ is transitive, it follows that Π ∝ Π2 − since Π∈NP was arbitrary, Π ∝ Π2 for all Π∈NP − and hence Π2 is NP-complete 26 Proving NP-completeness The first NP-complete problem? Name: Satisfiability (SAT) Instance: Boolean expression B in conjunctive normal form (CNF) − CNF: C1 ∧ C2 ∧ … ∧ Cn where each Ci is a clause − Clause C: (l1 ∨ l2 ∨ … ∨ lm) where each lj is a literal − Literal l: a variable x or its negation x Question: is B satisfiable? − i.e. can values be assigned to the variables that make B true? Example: − B = (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x3 ∨ x4) ∧ (x2 ∨ x4) ∧ (x2 ∨ x3 ∨ x4) − B is satisfiable: x1=true, x2=false, x3=true, x4=true 27 Proving NP-completeness The first NP-complete problem? Cook’s Theorem (1971): Satisfiability (SAT) is NP-complete − the proof consists of a generic polynomial-time reduction to SAT from an abstract definition of a general problem in the class NP − the generic reduction could be instantiated to give an actual reduction for each individual NP problem Given Cook’s theorem, to prove a decision problem Π is NP-complete it is sufficient to show that: − Π is in NP − there exists a polynomial-time reduction from SAT to Π 28 Clique is NP-complete Name: Clique Problem (CP) Instance: a graph G and a target integer K Question: does G contain a clique of size K? − i.e. a set of K vertices for which there is an edge between all pairs To prove Clique is NP –complete − show CP is in NP (straightforward) • guess the set of K vertices • check if it’s a clique (in polynomial time) • get “yes”-instances and “no”-instances − there exists a polynomial-time reduction from SAT to CP • proof at the end of the slide notes, not examinable • video of the proof and example available on Moodle 29 Problem restrictions A restriction of a problem consists of a subset of the instances of the original problem − if a restriction of a given decision problem Π is NP-complete, then so is Π − given NP-complete problem Π, a restriction of Π might be NP-complete or it might be easier to solve For example a clique restricted to cubic graphs is in P − (a cubic graph is a graph in which every vertex belongs to 3 edges) − a largest clique has size at most 4 so exhaustive search is O(n4) − for any target K>4 we directly return the answer “no” While graph colouring restricted to cubic graphs is NP-complete − not proved here 30 Problem restrictions K-colouring − restriction of Graph Colouring for a fixed number K of colours − 2-colouring is in P (it reduces to checking the graph is bipartite) − 3-colouring is NP-complete K-SAT − restriction of SAT in which every clause contains exactly K literals − 2-SAT is in P (proof is a tutorial exercise) − 3-SAT is NP-complete − showing 3-SAT ∈ NP is easy we will just find the polynomial-time reduction SAT ∝ 3-SAT 31 SAT ∝ 3-SAT Given instance B of SAT will construct an instance B’ of 3-SAT For each clause C of B we construct a number of clauses of B’ − if C = l1, we introduce 2 addition variables x1 and x2 and add the clauses (l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2) to B’ − B’ holds if and only if all the clauses (l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2) hold (B’ is a conjunction of clauses) − for any assignment to x1 and x2 for all the clauses to hold requires l1 to holds (be true) − i.e. all clauses hold if and only if the clause C holds 32 SAT ∝ 3-SAT Given instance B of SAT will construct an instance B’ of 3-SAT For each clause C of B we construct a number of clauses of B’ − if C = l1, we introduce 2 addition variables x1 and x2 and add the clauses (l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2) to B’ − if C = (l1 ∨ l2), we introduce 1 additional variable y and add the clauses (l1 ∨ l2 ∨ y) and (l1 ∨ l2 ∨ y) to B’ − B’ holds if and only if both the clauses (l1 ∨ l2 ∨ y) and (l1 ∨ l2 ∨ y) hold − for any assignment to y this requires (l1 ∨ l2) holds i.e. both clauses hold if and only if the clause C holds 33 SAT ∝ 3-SAT Given instance B of SAT will construct an instance B’ of 3-SAT For each clause C of B we construct a number of clauses of B’ − if C = l1, we introduce 2 addition variables x1 and x2 and add the clauses (l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2) to B’ − if C = (l1 ∨ l2), we introduce 1 addition variable y and add the clauses (l1 ∨ l2 ∨ y) and (l1 ∨ l2 ∨ y) to B’ − if C = (l1 ∨ l2 ∨ l3), we add the clause C to B’ 34 SAT ∝ 3-SAT Given instance B of SAT will construct an instance B’ of 3-SAT For each clause C of B we construct a number of clauses of B’ − if C = l1, we introduce 2 addition variables x1 and x2 and add the clauses (l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2) to B’ − if C = (l1 ∨ l2), we introduce 1 addition variable y and add the clauses (l1 ∨ l2 ∨ y) and (l1 ∨ l2 ∨ y) to B’ − if C = (l1 ∨ l2 ∨ l3), we add the clause C to B’ − if C = (l1 ∨ … ∨ lk) and k>3, we introduce k-3 additional variables z1,…,zk-3 and add the clauses (l1 ∨ l2 ∨ z1), (z1 ∨ l3 ∨ z2), (z2 ∨ l4 ∨ z3),…, (zk-4 ∨ lk-2 ∨ zk-3), (zk-3 ∨ lk-1 ∨ lk) to B’ 35 SAT ∝ 3-SAT Given instance B of SAT will construct an instance B’ of 3-SAT For each clause C of B we construct a number of clauses of B’ − if C = l1, we introduce 2 addition variables x1 and x2 and add the clauses (l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2),(l1 ∨ x1 ∨ x2), (l1 ∨ x1 ∨ x2) to B’ − if C = (l1 ∨ l2), we introduce 1 addition variable y and add the clauses (l1 ∨ l2 ∨ y) and (l1 ∨ l2 ∨ y) to B’ − if C = (l1 ∨ l2 ∨ l3), we add the clause C to B’ − if C = (l1 ∨ … ∨ lk) and k>3, we introduce k-3 additional variables z1,…,zk-3 and add the clauses (l1 ∨ l2 ∨ z1), (z1 ∨ l3 ∨ z2), (z2 ∨ l4 ∨ z3),…, (zk-4 ∨ lk-2 ∨ zk-3), (zk-3 ∨ lk-1 ∨ lk) to B’ − again all clauses hold if and only if C holds 36 Coping with NP-completeness What to do if faced with an NP-complete problem? Maybe only a restricted version is of interest (which maybe in P) − e.g. 2-SAT, 2-colouring are in P Seek an exponential-time algorithm improving on exhaustive search − e.g. backtracking, branch-and-bound − should extend the set of solvable instances in a reasonable time For an optimisation problem (e.g. calculating min/max value) − settle for an approximation algorithm that runs in polynomial time − especially if it gives a provably good result (within some factor of optimal) − use a heuristic • e.g. genetic algorithms, simulated annealing, neural networks For a decision problem − settle for a probabilistic algorithm correct answer with high probability 37 Next - Section 5 - Computability Introduction The halting problem Models of computation − finite-state automata − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 38 Clique is NP-complete: proof Name: Clique Problem (CP) Instance: a graph G and a target integer K Question: does G contain a clique of size K? − i.e. a set of K vertices for which there is an edge between all pairs To prove Clique is NP –complete − show CP is in NP (straightforward) • guess the set of K vertices • check if it’s a clique (in polynomial time) • get “yes”-instances and “no”-instances − there exists a polynomial-time reduction from SAT to CP 39 Clique is NP-complete To complete the proof we need to show SAT  CP − i.e. a polynomial time reduction from SAT to CP This is not examinable – this is just to show you that it is possible to build PTRs between very different problems 40 Clique is NP-complete To complete the proof we need to show SAT  CP − i.e. a polynomial time reduction from SAT to CP Given an instance B of SAT we construct (G,K) an instance of CP − K number of clauses of B − vertices of G are pairs (l,C) where l is a literal in clause C − {(l,C),(m,D)} is an edge of G if and only if l≠¬m and C≠D • recall that ¬(¬x)=x so l≠¬m is equivalent to ¬l≠m • edge if distinct literals from different clauses can be satisfied simultaneously − polynomial time construction (O(n2) where n is the number of literals) • worst case: to construct edges we need to compare every literal with every other literal This is a polynomial time reduction since: − B has a satisfying assignment if and only if G has a clique of size K 41 Clique is NP-complete To prove it is a polynomial time reduction we can show: If B has a satisfying assignment, then − if we choose a true literal in each clause the corresponding vertices form a clique of size K in G If G has a clique of size K, then − assigning each literal associated with a vertex in the clique to be true yields a satisfying assignment for B 42 Clique is NP-complete Why does the construction work? {(l,C),(m,D)} is an edge if and only if l≠¬m and C≠D − only edges between literals in distinct clauses − only edges between literals that can be satisfied simultaneously Therefore in a clique of size K (recall K is the number of clauses) − must include one literal from each clause (i.e. from K clauses) − we can satisfy all the literals in the clique simultaneously − this means we can satisfy all clauses • a clause is a disjunction of literals and we can satisfy one of the literals − and therefore satisfy B • B is the conjunction of the clauses and we satisfy all the clauses 43 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C Clique is NP-complete - Example 44 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C Clique is NP-complete - Example 45 C1 x2 x1 x3 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C Clique is NP-complete - Example 46 C1 C2 x1 x1 x3 x4 x3 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C Clique is NP-complete - Example 47 C1 C2 C4 C3x2 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C − {(l,C),(m,D)} is an edge if and only if l≠¬m and C≠D Clique is NP-complete - Example 48 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C − {(l,C),(m,D)} is an edge if and only if l≠¬m and C≠D Clique is NP-complete - Example 49 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C − {(l,C),(m,D)} is an edge if and only if l≠¬m and C≠D Clique is NP-complete - Example 50 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C − {(l,C),(m,D)} is an edge if and only if l≠¬m and C≠D Clique is NP-complete - Example 51 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G − vertices of G are pairs (l,C) where l is a literal in clause C − {(l,C),(m,D)} is an edge if and only if l≠¬m and C≠D Clique is NP-complete - Example 52 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G G has a clique of size 4 if and only if B has a satisfying assignment Clique is NP-complete 53 C1 C2 C4 C3 x1 x1 x3 x4 x3 x4x2 x3 x4 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G G has a clique of size 4 if and only if B has a satisfying assignment satisfying assignment Clique is NP-complete 54 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2 B = (x1∨x2∨x3)∧(x1∨x3∨x4)∧(x2∨x4)∧(x2∨x3∨x4) − there are K = 4 clauses The graph G G has a clique of size 4 if and only if B has a satisfying assignment satisfying assignment: x1,x2,x3,x4 are true clique of size 4 Clique is NP-complete 55 C1 C2 C4 C3 x4 x1 x1 x3 x4 x3 x4x2 x3 x2 x2","libVersion":"0.3.2","langs":""}