{"path":"software engineering/year 2/semester 2/Algorithmics/Slides/3. Graphs and Graph Algorithms/3.1 Graphs and graph algorithms.pdf","text":"Algorithmics Dr. Oana Andrei School of Computing Science University of Glasgow oana.andrei@glasgow.ac.uk GA Algorithmics 2025 Lecture 5 Section 3 – Graphs and graph algorithms Graph basics - recap − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − depth/breadth first search Topological ordering Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) 2 Section 3 – Graphs and graph algorithms Graph basics – recap − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − depth/breadth first search Topological ordering Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) 3 Graph basics (undirected) graph G = (V,E) − V is finite set of vertices (the vertex set) − E is set of edges, each edge is a subset of V of size 2 (the edge set) 4 Graph basics (undirected) graph G = (V,E) − V is finite set of vertices (the vertex set) − E is set of edges, each edge is a subset of V of size 2 (the edge set) Pictorially: − a vertex is represented by a point 5 a b c x y z V= {a,b,c,x,y,z} E= { {a,x},{a,y},{a,z}, {b,x},{b,y},{b,z}, {c,x},{c,y},{c,z} } Graph basics (undirected) graph G = (V,E) − V is finite set of vertices (the vertex set) − E is set of edges, each edge is a subset of V of size 2 (the edge set) Pictorially: − a vertex is represented by a point − an edge by a line joining the relevant pair of points 6 a b c x y z V= {a,b,c,x,y,z} E= { {a,x},{a,y},{a,z}, {b,x},{b,y},{b,z}, {c,x},{c,y},{c,z} } Graph basics (undirected) graph G = (V,E) − V is finite set of vertices (the vertex set) − E is set of edges, each edge is a subset of V of size 2 (the edge set) Pictorially: − a vertex is represented by a point − an edge by a line joining the relevant pair of points 7 a b c x y z V= {a,b,c,x,y,z} E= { {a,x},{a,y},{a,z}, {b,x},{b,y},{b,z}, {c,x},{c,y},{c,z} } Graph basics (undirected) graph G = (V,E) − V is finite set of vertices (the vertex set) − E is set of edges, each edge is a subset of V of size 2 (the edge set) Pictorially: − a vertex is represented by a point − an edge by a line joining the relevant pair of points − a graph can be drawn in different ways − e.g. two representations of the same graph 8 a b c x y z a b cx y z V= {a,b,c,x,y,z} E= { {a,x},{a,y},{a,z}, {b,x},{b,y},{b,z}, {c,x},{c,y},{c,z} } Graph basics In this graph: 9 a b c x y z a b cx y z Graph basics In this graph: − vertices a & z are adjacent that is {a,z} is an element of the edge set E 10 a b c x y z a b cx y z Graph basics In this graph: − vertices a & z are adjacent that is {a,z} is an element of the edge set E − vertices a & b are non-adjacent that is {a,b} is not an element of E 11 a b c x y z a b cx y z Graph basics In this graph: − vertices a & z are adjacent that is {a,z} is an element of the edge set E − vertices a & b are non-adjacent that is {a,b} is not an element of E − vertex a is incident to edge {a,x} 12 a b c x y z a b cx y z Graph basics In this graph: − vertices a & z are adjacent that is {a,z} is an element of the edge set E − vertices a & b are non-adjacent that is {a,b} is not an element of E − vertex a is incident to edge {a,x} − a➝x➝b➝y➝c is a path of length 4 (number of edges) 13 a b c x y z a b cx y z Graph basics In this graph: − vertices a & z are adjacent that is {a,z} is an element of the edge set E − vertices a & b are non-adjacent that is {a,b} is not an element of E − vertex a is incident to edge {a,x} − a➝x➝b➝y➝c is a path of length 4 (number of edges) − a➝x➝b➝y➝a is a cycle of length 4 14 a b c x y z a b cx y z Graph basics In this graph: − vertices a & z are adjacent that is {a,z} is an element of the edge set E − vertices a & b are non-adjacent that is {a,b} is not an element of E − vertex a is incident to edge {a,x} − a➝x➝b➝y➝c is a path of length 4 (number of edges) − a➝x➝b➝y➝a is a cycle of length 4 − all vertices have degree 3 • i.e. all vertices are incident to three edges 15 a b c x y z a b cx y z Graph basics - Definitions 16 A non-connected graph has two or more connected components A graph is: connected, if every pair of vertices is joined by a path •A graph is a tree if it is connected and acyclic (no cycles) a tree with n vertices has n-1 edges - at least n-1 edges to be connected - at most n-1 edges to be acyclic •A graph is a forest if it is acyclic and components are trees yx u wv z Graph basics - Definitions 17 A graph is bipartite if the vertices are in two disjoint sets U & W and every edge joins a vertex in U to a vertex in W A graph is complete (a clique) if every pair vertices is joined by an edge it is complete since all edges between vertices in U and W are present K6, the clique on 6 vertices the complete bipartite graph K3,3 U W a b c x y z Graph basics - Definitions 18 A graph is bipartite if the vertices are in two disjoint sets U & W and every edge joins a vertex in U to a vertex in W A graph is complete (a clique) if every pair vertices is joined by an edge K6, the clique on 6 vertices bipartite graphs do not need to be complete U W a b c x y z Graph basics – Directed graphs A directed graph (digraph) D = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices Pictorially: edges are drawn as directed lines/arrows 19 u x y zw v for example (u,v),(w,y),(y,w)  E Graph basics – Directed graphs A directed graph (digraph) D = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices Pictorially: edges are drawn as directed lines/arrows − u is adjacent to v and v is adjacent from u 20 u x y zw v for example (u,v),(w,y),(y,w)  E Graph basics – Directed graphs A directed graph (digraph) D = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices Pictorially: edges are drawn as directed lines/arrows − u is adjacent to v and v is adjacent from u − y has in-degree 2 21 u x y zw v for example (u,v),(w,y),(y,w)  E Graph basics – Directed graphs A directed graph (digraph) D = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices Pictorially: edges are drawn as directed lines/arrows − u is adjacent to v and v is adjacent from u − y has in-degree 2 and out-degree 1 22 u x y zw v for example (u,v),(w,y),(y,w)  E Graph basics – Directed graphs A directed graph (digraph) D = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices Pictorially: edges are drawn as directed lines/arrows − u is adjacent to v and v is adjacent from u − y has in-degree 2 and out-degree 1 In a digraph, paths and cycles must follow edge directions • e.g. u ➝ w ➝ x is a path 23 u x y zw v for example (u,v),(w,y),(y,w)  E Graph basics – Directed graphs A directed graph (digraph) D = (V,E) − V is the finite set of vertices and E is the finite set of edges − here each edge is an ordered pair (x,y) of vertices Pictorially: edges are drawn as directed lines/arrows − u is adjacent to v and v is adjacent from u − y has in-degree 2 and out-degree 1 In a digraph, paths and cycles must follow edge directions • e.g. u ➝ w ➝ x is a path and w ➝ y ➝ w is a cycle 24 u x y zw v for example (u,v),(w,y),(y,w)  E Section 3 – Graphs and graph algorithms Graph basics − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − breadth/depth first search Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) Topological ordering 25 Graph representations – Undirected graphs Undirected graph: Adjacency matrix − one row and column for each vertex − row i, column j contains a 1 if ith and jth vertices adjacent, 0 otherwise Undirected graph: Adjacency lists − one list for each vertex − list i contains an entry for j if the vertices i and j are adjacent 26 Graph representations – Undirected graphs Undirected graph G 27 Adjacency matrix for G u v w x y z u: 0 1 0 1 0 0 v: 1 0 1 1 1 0 w: 0 1 0 1 1 0 x: 1 1 1 0 1 0 y: 0 1 1 1 0 1 z: 0 0 0 0 1 0 |V|×|V| array Adjacency lists for G u: v➝x v: u➝w➝x➝y w: v➝x➝y x: u➝v➝w➝y y: v➝w➝x➝z z: y 2×|E| entries in all yx u wv z Graph representations – Undirected graphs Undirected graph G 28 Adjacency matrix for G u v w x y z u: 0 1 0 1 0 0 v: 1 0 1 1 1 0 w: 0 1 0 1 1 0 x: 1 1 1 0 1 0 y: 0 1 1 1 0 1 z: 0 0 0 0 1 0 |V|×|V| array Adjacency lists for G u: v➝x v: u➝w➝x➝y w: v➝x➝y x: u➝v➝w➝y y: v➝w➝x➝z z: y 2×|E| entries in all yx u wv z Graph representations – Directed graphs Directed graph: Adjacency matrix − one row and column for each vertex − row i, column j contains a 1 if there is an edge from i to j and 0 otherwise Directed graph: Adjacency lists − one list for each vertex − the list for vertex i contains vertex j if there is an edge from i to j 29 Graph representations – Directed graphs Directed graph D 30 Adjacency matrix for D u v w x y z u: 0 1 1 0 0 0 v: 0 0 0 0 0 0 w: 0 0 0 1 1 0 x: 0 0 0 0 0 0 y: 0 0 1 0 0 0 z: 0 0 0 0 1 0 |V|×|V| array u x y zw v Adjacency lists for D u: v➝w v: w: x➝y x: y: w z: y |E| entries in all Graph representations – Directed graphs Directed graph D 31 Adjacency matrix for D u v w x y z u: 0 1 1 0 0 0 v: 0 0 0 0 0 0 w: 0 0 0 1 1 0 x: 0 0 0 0 0 0 y: 0 0 1 0 0 0 z: 0 0 0 0 1 0 |V|×|V| array u x y zw v Adjacency lists for D u: v➝w v: w: x➝y x: y: w z: y |E| entries in all Recall adjacency list for an undirected graph − one list for each vertex − list i contains an element for j if the vertices i and j are adjacent Implementation: define classes for − the entries of adjacency lists − the vertices (includes a linked list representing its adjacency list) − graphs (includes the size of the graph and an array of vertices) • array allows for efficient access using “index” of a vertex Implementation – Adjacency lists 32 adjacency lists for G v: w➝x➝y w: v➝x➝y x: v➝w➝y y: v➝w➝x➝z z: y y x wv z graph G Implementation – Adjacency lists 33 /** class to represent an entry in the adjacency list of a vertex in a graph */ public class AdjListNode { private int vertexIndex; // the vertex index of the entry // possibly other fields, for example representing properties // of the edge such as weight, capacity, … /** creates a new entry for vertex indexed i */ public AdjListNode(int i){ vertexIndex = i; } public int getVertexIndex(){ // gets the vertex index of the entry return vertexIndex; } public void setVertexIndex(int i){ // sets vertex index to i vertexIndex = i; } } Implementation – Adjacency lists 34 import java.util.LinkedList; // we require the linked list class /** class to represent a vertex in a graph */ public class Vertex { private int index; // the index of this vertex private LinkedList<AdjListNode> adjList; // the adjacency list of vertex // possibly other fields, e.g. representing data stored at the node /** create a new instance of vertex with index i */ public Vertex(int i) { index = i; // set index adjList = new LinkedList<AdjListNode>();// create empty adjacency list } /** return the index of the vertex */ public int getIndex(){ return index; } Implementation – Adjacency lists 35 // class Vertex continued /** set the index of the vertex */ public void setIndex(int i){ index = i; } /** return the adjacency list of the vertex */ public LinkedList<AdjListNode> getAdjList(){ return adjList; } /** add vertex with index j to the adjacency list */ public void addToAdjList(int j){ adjList.addLast(new AdjListNode(j)); } /** return the degree of the vertex */ public int vertexDegree(){ return adjList.size(); } } import java.util.LinkedList; // again require the linked list class // (to add graph algorithms we will need to access adjacency lists) /** class to represent a graph */ public class Graph { private Vertex[] vertices; // array of vertices for easy access private int numVertices = 0; // number of vertices // possibly other fields representing properties of the graph /** Create a Graph with n vertices indexed 0,...,n-1 */ public Graph(int n) { numVertices = n; vertices = new Vertex[n]; for (int i = 0; i < n; i++) vertices[i] = new Vertex(i); } /** returns number of vertices in the graph */ public int size(){ return numVertices; } } Implementation – Adjacency lists 36 Section 3 – Graphs and graph algorithms Graph basics − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − depth/breadth first search Topological ordering Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) 37 Graph search and traversal algorithms Graph search and traversal algorithms − a systematic way to explore a graph (when starting from some vertex) Example: web crawler collects data from hypertext documents by traversing a directed graph D where − vertices are hypertext documents − (u,v) is an edge if document u contains a hyperlink to document v A search/traversal visits all vertices by travelling along edges − traversal is efficient if it explores graph in O(|V|+|E|) time 38 u x y zw v Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further 39 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further 40 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further 41 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further 42 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further 43 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached 44 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached 45 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices 46 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices 47 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices 48 Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices 49 From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices Depth first search/traversal (DFS) 50 From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices Repeat for other components (if any) Depth first search/traversal (DFS) 51 From starting vertex − follow a path of unvisited vertices until path can be extended no further − then backtrack along the path until an unvisited vertex can be reached − continue until we cannot find any unvisited vertices Repeat for other components (if any) The edges traversed form a spanning tree (or forest) − a depth-first spanning tree (forest) − spanning tree of a graph is a tree composed of all the vertices and some (or perhaps all) of the edges of the graph Depth first search/traversal (DFS) 52 Depth first traversal - Example Undirected graph G 53 current vertex 1 denotes vertex has been visited Depth first traversal - Example Undirected graph G 54 current vertex 1 2 denotes vertex has been visited Depth first traversal - Example Undirected graph G 55 current vertex 1 2 3 denotes vertex has been visited Depth first traversal - Example Undirected graph G 56 current vertex 1 2 4 3 denotes vertex has been visited Depth first traversal - Example Undirected graph G 57 current vertex 1 2 4 3 denotes vertex has been visited Depth first traversal - Example Undirected graph G 58 current vertex 1 2 4 3 denotes vertex has been visited Depth first traversal - Example Undirected graph G 59 1 2 4 current vertex 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 60 1 2 4 current vertex 3 backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 61 current vertex 1 2 4 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 62 current vertex 1 2 4 5 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 63 current vertex 1 2 4 5 6 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 64 current vertex 1 2 4 5 6 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 65 current vertex 1 2 4 5 6 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 66 1 2 4 5 6 3 backtrack current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 67 1 2 4 5 6current vertex 3 backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 68 1 2 4 5 6 current vertex 7 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 69 1 2 4 5 6 current vertex 7 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 70 1 2 4 5 6 current vertex 7 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 71 1 2 4 5 6 current vertex 7 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 72 1 2 4 5 6 current vertex 7 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 73 1 2 4 5 6 current vertex 7 3 backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 74 1 2 4 5 6 7 3 current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 75 1 2 4 5 6 7 3 current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 76 1 2 4 5 6 7 3 current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 77 1 2 4 5 6 7 3 current vertex backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 78 1 2 4 5 6 7 3 backtrack current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 79 1 2 4 5 6 current vertex 7 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 80 1 2 3 4 5 6 7 current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 81 1 2 3 4 5 6 7 current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 82 1 2 3 4 5 6 7 current vertex backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 83 1 2 3 4 5 6 7 backtrack current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 84 1 2 4 5 6 7 current vertex 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 85 1 2 4 5 6 7 current vertex 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 86 1 2 4 5 6 7 current vertex 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 87 1 2 4 5 6 7 current vertex 3 backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 88 1 2 4 5 6 7 3 backtrack current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 89 1 2 4 5 6 7 3 current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 90 1 2 4 5 6 7 current vertex 8 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 91 1 2 4 5 6 7 current vertex 8 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 92 1 2 4 5 6 7 current vertex 8 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 93 1 2 4 5 6 7 current vertex 8 3 backtrack i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 94 1 2 4 5 6 7 8 3 backtrack current vertex i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G 95 1 2 4 5 6 7 8 current vertex 3 i means all adjacent vertices of i have been considered denotes vertex has been visited Depth first traversal - Example Undirected graph G Depth first spanning tree of G 96 1 2 4 5 6 7 8 3 Is it unique? Depth first traversal - Example Undirected graph G A depth first spanning tree of G 97 1 2 4 5 6 7 8 3 What if from 1 we went to 7 first? Recall adjacency list implementation Class: adjacency node − represents an element of an adjacency list − includes the index of the corresponding vertex Class: vertex − represents a single vertex of the graph − includes linked list of adjacency nodes representing the adjacent vertices Class: graph − an array of vertices 98 Implementation – DFS – Add to vertex class 99 private boolean visited; // has vertex been visited in a traversal? private int pred; // index of the predecessor vertex in a traversal public boolean getVisited(){ // was this vertex visited? return visited; } public void setVisited(boolean b){ // on 1st encounter, set as true visited = b; } public int getPred(){ // for when we’re backtracking return pred; } public void setPred(int i){ // when we find new vertex during search pred = i; } Implementation – DFS – Add to graph class 100 /** visit vertex v, with predecessor index p, during a dfs */ private void visit(Vertex v, int p){ v.setVisited(true); // update as now visited v.setPred(p); // set predecessor (indicates edge used to find vertex) LinkedList<AdjListNode> L = v.getAdjList(); // get adjacency list for (AdjListNode node : L){ // go through all adjacent vertices int i = node.getIndex(); // find index of current vertex in list if (!vertices[i].getVisited()) // if vertex has not been visited visit(vertices[i], v.getIndex()); // continue dfs search from it // setting the predecessor vertex index to the index of v } } /** carry out a depth first search/traversal of the graph */ public void dfs(){ for (Vertex v : vertices) v.setVisited(false); // initialise for (Vertex v : vertices) if (!v.getVisited()) visit(v,-1); // if vertex is not yet visited, then start dfs on vertex w/ predecessor // -1 is used to indicate v was not found through an edge of the graph } Analysis – Depth first search Each vertex is visited, and each element in the adjacency lists is processed, so overall O(n+m) − where n is the number of vertices and m the number of edges Can be adapted to the adjacency matrix representation − but now O(n2) since look at every entry of the adjacency matrix Some applications − to determine if a given graph is connected − to identify the connected components of a graph − to determine if a given graph contains a cycle (see tutorial 5) − to determine if a given graph is bipartite (see tutorial 5) − 101 Recall - Depth first search/traversal (DFS) From starting vertex − follow a path of unvisited vertices until path can be extended no further 102 Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex 103 current vertex Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue (FIFO) 104 r s t queue = 〈r,s,t〉 current vertex Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue (FIFO) 105 r s t queue = 〈s,t〉 Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue 106 queue = 〈s,t,u,v,w〉 r s t u v w Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue 107 queue = 〈t,u,v,w〉 r s t u v w Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue 108 queue = 〈u,v,w〉 r s t u v w Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue 109 queue = 〈u,v,w,x〉 r s t u v w x Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue 110 queue = 〈v,w,x〉 r s t u v w x Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited therefore visited vertices are added/removed from a queue 111 queue = 〈v,w,x,y〉 r s t u v w x y Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited − continue until all vertices in current component have been processed 112 Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited − continue until all vertices in current component have been processed − then repeat for other components (if there are any) 113 Breadth first search/traversal (BFS) Search fans out as widely as possible at each vertex − from the current vertex, visit all the adjacent vertices this is referred to as processing the current vertex − vertices are processed in the order in which they are visited − continue until all vertices in current component have been processed − then repeat for other components (if there are any) Again the edges traversed form a spanning tree (or forest) − a breadth-first spanning tree (forest) − spanning tree of a graph is tree composed of all the vertices and some (or perhaps all) of the edges of the graph 114 Breadth first traversal - Example Undirected graph G 115 a means vertex has been processed queue = 〈a〉 b e g h f d c v denotes vertex has been visited Breadth first traversal - Example Undirected graph G 116 a means vertex has been processed queue = 〈〉 b e g h f d c v current vertex denotes vertex has been visited Breadth first traversal - Example Undirected graph G 117 a means vertex has been processed queue = 〈b,c,e〉 b e g h f d c current vertex v denotes vertex has been visited Undirected graph G Breadth first traversal - Example 118 a means vertex has been processed queue = 〈c,e〉 b e g h f d c current vertex v denotes vertex has been visited Undirected graph G Breadth first traversal - Example 119 a means vertex has been processed b e g h f d c current vertex v denotes vertex has been visited queue = 〈c,e〉 Breadth first traversal - Example Undirected graph G 120 a means vertex has been processed b e g h f d c current vertex v denotes vertex has been visited queue = 〈e〉 Breadth first traversal - Example Undirected graph G 121 a means vertex has been processed queue = 〈e,d,f〉 b e g h f d c current vertex v denotes vertex has been visited Undirected graph G Breadth first traversal - Example 122 a means vertex has been processed queue = 〈d,f〉 b e g h f d c current vertex v denotes vertex has been visited Undirected graph G Breadth first traversal - Example 123 a means vertex has been processed queue = 〈d,f,g〉 b e g h f d c current vertex v denotes vertex has been visited Undirected graph G Breadth first traversal - Example 124 a means vertex has been processed queue = 〈f,g〉 b e g h f d c current vertex v denotes vertex has been visited Undirected graph G Breadth first traversal - Example 125 a means vertex has been processed b e g h f d c current vertex v denotes vertex has been visited queue = 〈f,g〉 Breadth first traversal - Example Undirected graph G 126 a means vertex has been processed b e g h f d c current vertex v denotes vertex has been visited queue = 〈g〉 Breadth first traversal - Example Undirected graph G 127 a means vertex has been processed b e g h f d c current vertex v denotes vertex has been visited queue = 〈g〉 Breadth first traversal - Example Undirected graph G 128 a means vertex has been processed b e g h f d c current vertex v denotes vertex has been visited queue = 〈〉 Breadth first traversal - Example Undirected graph G 129 a means vertex has been processed queue = 〈h〉 b e g h f d c current vertex v denotes vertex has been visited Breadth first traversal - Example Undirected graph G 130 a v means vertex has been processed queue = 〈〉 b e g h f d c current vertex denotes vertex has been visited Breadth first traversal - Example Undirected graph G 131 a v means vertex has been processed queue = 〈〉 b e g h f d c current vertex denotes vertex has been visited Breadth first traversal - Example Undirected graph G A breadth first spanning tree of G 132 ab e g f d c h Recall adjacency list implementation Class: adjacency node − represents an element of an adjacency list − includes a vertex index (the vertex the element corresponds to) Class: vertex − represents a single vertex of the graph − includes linked list of adjacency nodes representing the adjacent vertices Class: graph − an array of vertices 133 Implementation – Breadth first search 134 for (Vertex v : vertices) v.setVisited(false); // initialise LinkedList<Vertex> queue = new LinkedList<Vertex>(); // set up queue for (Vertex v : vertices) { // go through vertices in the graph if (!v.getVisited()) { // vertex not visited (start search) v.setVisited(true); // now visited v.setPredecessor(-1); // v initial/starting vertex queue.add(v); // ready to be processed (add to queue) while (!queue.isEmpty()) { // something to process Vertex u = queue.remove(); // get next vertex from queue LinkedList<AdjListNode> list = u.getAdjList(); // get adj list for u for (AdjListNode node : list) { // go through adj list of u Vertex w = vertices[node.getVertexIndex()]; // next vertex in list if (!w.getVisited()) { // not previous found w.setVisited(true); // now visited w.setPredecessor(u.getIndex()); // set predecessor of w to be u queue.add(w); // add to queue } } } } } Breadth first search - complexity Each vertex is visited and queued exactly once Each adjacency list is traversed once (when it’s processed) So overall O(n+m) − n is the number of vertices and m number of edges We can adapt to adjacency matrix representation − complexity O(n2) as for DFS − have to access every element of the matrix 135 Breadth first search - application Computing the distance between two vertices in a graph − let v and w be to vertices in the graph − the distance is the number of edges in the shortest path from v to w Algorithm − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time, assign its distance to be 1 + the distance to its predecessor in the BF spanning tree − stop when w is reached 136 Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 137 v w w v Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 138 v w number beside each vertex indicates the distance from v w 0 v Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 139 v w number beside each vertex indicates the distance from v w v w 1 1 10 v Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 140 number beside each vertex indicates the distance from v w v w 1 1 10 2 2 v Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 141 number beside each vertex indicates the distance from v w v w 1 1 10 2 2 2 v Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 142 number beside each vertex indicates the distance from v w v w 1 1 10 2 2 2 3 v Distance between two vertices - Example Distance between v and w − assign distance to v to be 0 − carry out a breadth-first search from v − when visiting a new vertex for first time assign its distance to be 1+ the distance to its predecessor in the BF spanning tree 143 number beside each vertex indicates the distance from v v w v w 1 1 10 2 2 2 3 shortest path Next lecture Graph basics - recap − definitions: directed, undirected, connected, bipartite, … Graph representations − adjacency matrix/lists and implementation Graph search and traversal algorithms − depth/breadth first search Topological ordering Weighted graphs − shortest path (Dijkstra’s algorithm) − minimum spanning tree (Prim-Jarnik and Dijkstra’s refinement) 144","libVersion":"0.3.2","langs":""}