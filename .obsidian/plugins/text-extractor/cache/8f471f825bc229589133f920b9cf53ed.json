{"path":"software engineering/year 2/semester 1/Systems Programming/Slides/1. Learning C/Pointers.pdf","text":"Pointers Yehia Elkhatib COMPSCI2030 Systems ProgrammingMemory o DeÔ¨Ånition from the Cambridge Dictionary 1. the ability to remember information, experiences, and people 2. something that you remember from the past 3. the part of a computer in which information or programs are stored either permanently or temporarily, or the amount of space available on it for storing information What exactly is it? How do I use it? How should we think about memory? o We can think of memory as a sorting cabinet where each box stores the value of a variable o The variable name is the label which allows us to remember where we stored what How should we think about memory? o We can also think of memory as a single long street where each house has a unique address o We have some notion of spatial locality ¬ß houses close to each other are neighbours; others are far away Byte Addressable Memory o Every byte in memory has a unique address o On a 64-bit architecture, addresses are 64-bits (or 8 bytes) long ¬ß In theory, a 64-bit architecture can address up to 264 bytes = 16 exabytes ¬ß In practice, x86-64 only uses the lower 48 bits of an address, supporting up to 248 bytes = 256 TB o An address is made up of 12 hexadecimal numbers ‚àº 48 bits 0x000000000000 S 0x000000000001 y 0x000000000002 s 0x000000000003 t 0x000000000004 e 0x000000000005 m 0x000000000006 s . . . 0xFFFFFFFFFFFF To manipulate values in memory o We need 3 things: ¬ß get the memory address of a variable (i.e. pointer) ¬ß pass pointers (e.g. to functions) for manipulation ¬ß set a value at a pointer Variables in memory o As we learned: every variable in C is stored at a memory location that does not change over its lifetime o This location is identifiable by its address o Depending on the size of the data type, the value of the variables will span multiple bytes in memory o We can ask for the address of a variable in C using the address- of operator & int main() { int x = 42; int y = 23; printf(\"&x = %p\\n\", &x); // print the address of x printf(\"&y = %p\\n\", &y); // print the address of y } Pointers o We store the address of a variable as the value of another variable that we call a pointer o The dereference operator * allows us to access the value of the variable we are pointing to: o A pointer to a variable of data type t has the data type t * o Every pointer has the same size: the size of an address ¬ß on a 64-bit architecture, addresses are 8 bytes (or 64 bits) each ¬ß i.e size of a pointer is independent of the type it is pointing to int x = 42; int * pointer_to_x = &x; // this is a pointer referring to x printf(\"value of pointer_to_x: %p\\n\", pointer_to_x); // prints 0x77... printf(\"value of x: %d\\n\", *pointer_to_x); // prints 42 Pointers are normal variables o A pointer is a variable like any other o The pointer is stored at its own location o We can get the address of where the pointer is stored using & o We can store the address of a pointer in another pointer o We can change where a pointer points to int x = 42; // stored at 0x7ffeedbed3dc int * ptr = &x; // stored at 0x7ffeedbed3d0 printf(\"%p\\n\", &ptr); // prints 0x7ffeedbed3d0 int * * ptr_to_ptr = &ptr; // stored at 0x7ffeed7ed3c8 int y = 23; // stored at 0x7ffeebaf23c4 ptr = &y; Pointers and const o In C every variable can be annotated with the type qualifier const, indicating that its value can not be changed ¬ß This is enforced by the compiler o Pointers can be const in three ways 1. The pointer itself, i.e. the address, cannot be changed: float * const ptr 2. The value we are pointing to cannot be changed: const float * ptr 3. Both value and pointer cannot be changed: const float * const ptr Call-by-value Revisited o We learned last time that arguments are passed by-value ¬ß i.e. the value of the argument is copied into the function parameter o This is also true for pointers o Arrays are treated specially ¬ß a pointer to the Ô¨Årst element is copied instead of the entire array o The array is treated like a pointer ¬ß in fact int param[] and int * param are interchangeable float average(float array[], int size) { float sum = 0.0f; for (int i = 0; i < size; i++) { sum += array[i]; } return sum / size; } float average(float array[], int size); float average(float * array, int size); Pointers and Arrays o The name of an array refers to the address of its first element o We can use the array indexing notation on pointers o The expressions ptr[i] and *(ptr + i) are equivalent o Two important differences: ¬ß sizeof returns different values (size of array vs. size of pointer) ¬ß we cannot change an array, only its elements int vector[6] = {1, 2, 3, 4, 5, 6}; int * ptr = vector; // this is equivalent to: int * ptr = &(vector[0]); printf(\"5th element: %d\\n\", ptr[4]); // prints \"5th element: 5\" printf(\"%ld\\n\", sizeof(vector)); // prints '24' (== 6 * 4 bytes) printf(\"%ld\\n\", sizeof(ptr)); // prints '8' (size of a pointer) vector = another_vector; // error: array type 'int [6]' is not assignable Pointers and NULL o Sometimes there is no meaningful value for a pointer at a certain time o We use the value 0 or the macro NULL to represent pointing to nothing o NULL often represents an erroneous state ¬ß e.g. an element was not found in an array o Dereferencing NULL will crash your program! ¬ß This has led to many software bugs ¬ß The inventor of NULL, Tony Hoare, called it his billion-dollar mistake // return pointer to value found in array; NULL otherwise float* search(float needle, float haystack[], int haystack_size) { for (int i = 0; i < haystack_size; i++) if (needle == haystack[i]) return &haystack[i]; return NULL; } Pointer Arithmetic o We can use pointer arithmetic to modify the value of a pointer 1. add / subtract integer values to/from a pointer 2. subtract two pointers from each other 3. compare pointers o Pointer arithmetic takes into account the size of the type the pointer is pointing to int vector[6] = {1, 2, 3, 4, 5, 6}; int * ptr = vector; // start at the beginning while (ptr <= &(vector[5])) { printf(\"%d \", *ptr); // print the element in the array ptr++; } // go to the next element int * i_ptr = &i; char* c_ptr = &c; i_ptr++; // this adds 4-bytes (1x sizeof(int)) to the address stored in i_ptr c_ptr+=2; // this adds 2-bytes (2x sizeof(char)) to the address stored in c_ptr Pointers and structs o Pointers are extremely useful in building data structures o For example, a linked list ¬ß each node has a value and a pointer to the next node struct node { char value; struct node * next; }; int main() { struct node c = {'c', NULL}; struct node b = {'b', &c}; struct node a = {'a', &b}; struct node * ptr = &a; while (ptr) { printf(\"%d\\n\", (*ptr).value); ptr = (*ptr).next; } } The last node in the list has a next-pointer to NULL We use a pointer to iterate over the linked list Command line arguments int main(int argc, char* argv[]) { ... } #include <stdio.h> int main(int argc, char * argv[]) { // print every command line argument for (int i = 0; i < argc; i++) printf(\"%s\\n\", argv[i]); } o This is the information entered after the program name when you start the program o argc speciÔ¨Åes the number of command line arguments o argv speciÔ¨Åes an array of command line arguments as strings ¬ß A single string is represented as an array of characters: char * ¬ß The type of argv char * [] can also be written char * * void * o Sometimes we want to write generic code to work with all data types ¬ß e.g. swapping two variables or sorting a list ¬ß To swap two variables x and y of arbitrary type, we copy all bytes at the location of x to y and vice versa o For this we write a function ¬ß it takes two pointers and the number of bytes to be swapped o void * is a generic pointer ¬ß every pointer is automatically convertible to it ¬ß only serves as an address pointing to something ü§∑ o We cannot access the value we are pointing to ¬ß we do not know what those bits mean ¬ß dereferencing a void pointer is forbidden void swap(void *x, void *y, size_t l) { char *a = x, *b = y, tmp; while(l--) { tmp = *a; *a++ = *b; *b++ = tmp; } } Checkpoint o Assume that you have declared an array using Which of the following comparisons are true? True True False Checkpoint o Write the prototype for a function that takes an array of pointers to type char as its one argument and returns void. o How would such function know how many elements are in the array of pointers passed to it? ¬ß It has no way of knowing. This value must be passed to the function as another argument. Tasks 4.A-B Lab Sheet","libVersion":"0.3.2","langs":""}