{"path":"university/year 2/semester 2/Algorithmics/Slides/5. Computability/5.1 Computability Part 1.pdf","text":"Algorithmics Dr. Oana Andrei School of Computing Science University of Glasgow oana.andrei@glasgow.ac.uk Algorithmics 2025 Lecture 10 Section 5 - Computability Introduction − unsolvable and undecidable problems − the tiling problem − Post’s correspondence problem − the halting problem Models of computation − finite-state automata − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 2 Section 5 - Computability Introduction − unsolvable and undecidable problems − the tiling problem − Post’s correspondence problem − the halting problem Models of computation − finite-state automata – first part − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 3 Introduction to Computability What is a computer? What can the black box do? − it computes a function that maps an input to an output Computability is concerned with which functions can be computed − a formal way of answering ‘what problems can be solved by a computer?’ − or alternatively ‘what problems cannot be solved by a computer?’ To answer such questions we require a formal definition − i.e. a definition of what a computer is − or what an algorithm is if we view a computer as a device that can execute an algorithm 5 black boxinput x output f(x) Unsolvable problems Some problems cannot be solved by a computer − even with unbounded time Example: The Tiling Problem (decision problem) − a tile is a 1×1 square, divided into 4 triangles by its diagonals with each triangle is given a colour − each tile has a fixed orientation (no rotations allowed) − example tiles: Instance: a finite set S of tile descriptions Question: can any finite area, of any size, be completely covered using only tiles of types in S, so that adjacent tiles colour match? 6 Tiling problem - Tiling a 5×5 square Available tiles: We can use these tiles to tile a 5×5 square as follows: 7 Tiling problem - Extending to a larger region Overlap the top two rows with the bottom two rows − obtain an 8×5 tiled area 8 Overlap the top two rows with the bottom two rows − obtain an 8×5 tiled area Next place two of these 8×5 rectangles side by side − with the right hand rectangle one row above the left hand rectangle 9 Tiling problem - Extending to a larger region Overlap the top two rows with the bottom two rows − obtain an 8×5 tiled area By repeating this pattern it follows that any finite area can be tiled 10 Tiling problem - Extending to a larger regionTiling problem - Tiling a 10×10 square Available tiles: 11 Tiling problem - Altering the tiles Original tiles: New tiles: Now impossible to tile a 3×3 square If we try: 12 Tiling problem - Altering the tiles Original tiles: New tiles: Now impossible to tile a 3×3 square If we try: 13 Tiling problem - Altering the tiles Original tiles: New tiles: Now impossible to tile a 3×3 square There are 39=19,683 possibilities if you want to try them all out… 14 Tiling problem Tiling problem: given a set of tile descriptions, can any finite area, of any size, be completely ‘tiled’ using only tiles from this set? There is no algorithm for the tiling problem − it’s been proved that for any algorithm A that we might try to formulate there is a set of tiles S for which either A does not terminate or A gives the wrong answer The problem is that: − “any size” means we do have to check all finite areas and there are infinitely many of these − and for certain sets of tile descriptions that can tile any area, there is no “repeated pattern” we can use − so to be correct the algorithm would really have to check all finite areas 15 Undecidable problems A problem Π that admits no algorithm is called non-computable or unsolvable If Π is a decision problem and Π admits no algorithm it is called undecidable The Tiling Problem is undecidable 16 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: • word constructed from Yi’s: 17 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: a • word constructed from Yi’s: aa 18 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: aabb • word constructed from Yi’s: aabbab 19 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: aabbabb • word constructed from Yi’s: aabbabbbab 20 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: aabbabbbaba • word constructed from Yi’s: aabbabbbabaa 21 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: aabbabbbabaabb • word constructed from Yi’s: aabbabbbabaabbab 22 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: aabbabbbabaabbaba • word constructed from Yi’s: aabbabbbabaabbaba 23 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 − X1 = abb, X2 = a, X3 = bab, X4 = baba, X5 = aba − Y1 = bbab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − correspondence is given by the sequence 2, 1, 1, 4, 1, 5 • word constructed from Xi’s: aabbabbbabaabbaba • word constructed from Yi’s: aabbabbbabaabbaba 24 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a 25 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − to get a match we must start with either 2 or 5 26 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − suppose we start with 2 • word constructed from Xi’s: a • word constructed from Yi’s: aa 27 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − but then must repeatedly follow with 2 as again nothing else matches • word constructed from Xi’s: aa • word constructed from Yi’s: aaaa 28 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − but then must repeatedly follow with 2 as again nothing else matches • word constructed from Xi’s: aaa • word constructed from Yi’s: aaaaaa 29 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − but then must repeatedly follow with 2 as again nothing else matches • word constructed from Xi’s: aaaa • word constructed from Yi’s: aaaaaaaa 30 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − suppose we start with 5 • word constructed from Xi’s: aba • word constructed from Yi’s: a 31 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − suppose we start with 5 must follow with 1 to get a match • word constructed from Xi’s: ababb • word constructed from Yi’s: abab 32 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − suppose we start with 5 must follow with 1, then we are stuck • word constructed from Xi’s: ababb • word constructed from Yi’s: abab 33 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Example: n=5 (with first letter from X1 and Y1 removed) − X1 = bb, X2 = a, X3 = bab, X4 = bab, X5 = aba − Y1 = bab, Y2 = aa, Y3 = ab, Y4 = aa, Y5 = a − follows that we can now never get a correspondence 34 Post’s correspondence problem (PCP) A word is a finite string over some given finite alphabet Instance: two finite sequences of words X1,…,Xn and Y1,…,Yn − the words are all over the same alphabet Question: does there exist a sequence i1,i2,…,ir of integers chosen from {1,…,n} such that Xi1Xi2…Xir = Yi1Yi2…Yir ? − i.e. concatenating the Xij's and the Yij's gives the same result Post’s Correspondence Problem is undecidable − there is no algorithm that will either always give the right answer or always terminate 35 The halting problem An impossible project: write a program Q that takes as input − a legal program X (say in Java) − an input string S for program X and returns as output − yes if program X halts (terminates) when run with input S − no if program X enters an infinite loop (doesn’t terminate) when run with input S It has been proved that no such program Q can exists, meaning the halting problem is undecidable 36 The halting problem Example (small) programs The program ‘test’ will terminate if and only if input n≠1 37 public void test(int n){ if (n == 1) while (true) null; } The halting problem Example (small) programs For example if ‘erratic’ is called with n=7 sequence of values: 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 Nobody knows whether ‘erratic’ terminates for all values of n 38 public int erratic(int n){ while (n != 1) if (n % 2 == 0) n = n/2; else n = 3*n + 1; } The halting problem - Undecidability A formal definition of the halting problem (HP) Instance: a legal Java program X and an input string S for X − can substitute any language for Java Question: does X halt when run with input S? Theorem: HP is undecidable − proof by contradiction – at the end of these slide notes − pre-recorded video available on Moodle − this proof is supplementary material - non examinable 39 Hierarchy of decision problems 40 Polynomial-time solvable e.g. String distance, Eulerian cycle Intractable e.g. Roadblock Undecidable e.g. Tiling Problem, Halting Problem NP-complete e.g. SAT, HC, TSDP Exactly one of these lines is real (depends on whether P equals NP) Section 5 - Computability Introduction The halting problem Models of computation − finite-state automata − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 41 Models of computation Attempts to define \"the black box” − we will look at three classical models of computation of increasing power • Finite-State Automata − simple machines with a fixed amount of memory − have very limited (but still useful) problem-solving ability • Pushdown Automata (PDA) − simple machines with an unlimited memory that behaves like a stack • Turing machines (TM) − simple machines with an unlimited memory that can be used essentially arbitrarily, in any way − these have essentially the same power as a typical computer 42 black boxinput x output f(x) Section 5 - Computability Introduction Models of computation − finite-state automata − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 43 Deterministic finite-state automata Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q • ((q,a),q’) ∈ T means if in state q and read a, then move to state q’ − deterministic means that if ((q,a1),q1), ((q,a2),q2) ∈ T either a1≠a2 or q1=q2 − i.e. for any state and action there is at most one move (i.e. no choice) 44 Deterministic finite-state automata Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q 45 q0 q2 aa a b q3q1 a,b b b initial state denoted by incomming arrow a a b b b add input tape (finite sequence of elements/actions from the alphabet) Deterministic finite-state automata Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q 46 q0 q2 aa a b q3q1 a,b b b accepting states denoted by double circles add input tape (finite sequence of elements/actions from the alphabet) a a b b b Deterministic finite-state automata Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q 47 q0 q2 aa a b q3q1 a,b b b control/program ((q0,a), q1) ((q0,b), q3) ((q1,a), q1) ((q1,b), q2) ((q2,a), q3) ((q2,b), q2) ((q3,a), q3) ((q3,b), q3) add input tape (finite sequence of elements/actions from the alphabet) Deterministic finite-state automata Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q 48 q0 q2 aa a b q3q1 a,b b b control/program ((q0,a), q1) ((q0,b), q3) ((q1,a), q1) ((q1,b), q2) ((q2,a), q3) ((q2,b), q2) ((q3,a), q3) ((q3,b), q3) add input tape (finite sequence of elements/actions from the alphabet) Deterministic finite-state automata Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q 49 q0 q2 aa a b q3q1 a,b b b control/program ((q0,a), q1) ((q0,b), q3) ((q1,a), q1) ((q1,b), q2) ((q2,a), q3) ((q2,b), q2) ((q3,a), q3) ((q3,b), q3) add input tape (finite sequence of elements/actions from the alphabet) Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 50 q0 q2 aa a b q3q1 a,b b b a a b b b Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 51 q0 q2 aa a b q3q1 a,b b b a a b b b Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 52 q0 q2 aa a b q3q1 a,b b b a a b b b Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 53 q0 q2 aa a b q3q1 a,b b b a a b b b Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 54 q0 q2 aa a b q3q1 a,b b b a a b b b Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 55 q0 q2 aa a b q3q1 a,b b b a a b b b Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 56 q0 q2 aa a b q3q1 a,b b b a a b b b string is accepted Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 57 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 58 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 59 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 60 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 61 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 62 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 63 q0 q2 aa a b q3q1 a,b b b a a b b b a Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 64 q0 q2 aa a b q3q1 a,b b b a a b b b a string is not accepted Deterministic finite-state automata A DFA defines a language − determines whether the string on the input tape belongs to that language − in other words, it solves a decision problem More precisely a DFA recognises or accepts a language − the input strings which when ‘run’ end in an accepting state Question: what language does this DFA recognise? 65 q0 q2 aa a b q3q1 a,b b b answer: the language consisting of the set of all strings comprising one or more a's followed by one or more b's Deterministic finite-state automata Recognises the language of strings containing two consecutive a’s Recognises the complement, i.e., the language of strings that do not contain two consecutive a’s 66 q0 q2 a b b q1 a,b a q2 a b b a,b a q1q0 Recognises strings that start and end with b However this is not a DFA, but a non-deterministic finite-state automaton (NFA) − in state q1 under b can move to q1 or q2 Recognition for NFA is similar to non-deterministic algorithms “solving” a decision problem − only require there exists a ‘run’ that ends in an accepting state − i.e. under one possible resolution of the nondeterministic choices the input is accepted Another example 67 q2 b b q1q0 b q2q1q0 b b b a Another example Recognises strings that start and end with b However this is not a DFA, but a non-deterministic finite-state automaton (NFA) − in state q1 under b can move to q1 or q2 But any NFA can be converted into a DFA Therefore non-determinism does not expand the class of languages that can be recognised by finite state automata − being able to guess does not give us any extra power 68 q2 b b q1q0 b q2q1q0 b a NFA to DFA reduction Can reduce a NFA to a DFA using the subset construction − states of the DFA are sets of states of the NFA − construction can cause a blow-up in the number of states • in the worst case from N states to 2N states Example (without blow-up) − recognises strings that start and end with b − NFA − DFA 69 {q1,q2} b b{q1}{q0} b a a q2 b b q1q0 b a Next time - Section 5 - Computability Introduction Models of computation − finite-state automata – regular languages and regular expressions − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 70 The halting problem An impossible project: write a program Q that takes as input − a legal program X (say in Java) − an input string S for program X and returns as output − yes if program X halts (terminates) when run with input S − no if program X enters an infinite loop (doesn’t terminate) when run with input S It has been proved that no such program Q can exists, meaning the halting problem is undecidable 71 The halting problem Example (small) programs The program ‘test’ will terminate if and only if input n≠1 72 public void test(int n){ if (n == 1) while (true) null; } The halting problem Example (small) programs For example if ‘erratic’ is called with n=7 sequence of values: 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 Nobody knows whether ‘erratic’ terminates for all values of n 73 public int erratic(int n){ while (n != 1) if (n % 2 == 0) n = n/2; else n = 3*n + 1; } The halting problem - Undecidability A formal definition of the halting problem (HP) Instance: a legal Java program X and an input string S for X − can substitute any language for Java Question: does X halt when run with input S? Theorem: HP is undecidable − proof by contradiction in the following slides − this is non examinable 74 Proving undecidability by reduction Suppose we can reduce any instance I of Π1 into an instance J of Π2 such that − I has a ‘yes’-answer for Π1 if and only if J has a \"yes\"-answer for Π2 (like PTRs but no need for J to be constructed in polynomial time, just need to be able to construct J) If Π1 is undecidable and we can perform such a reduction, then Π2 is undecidable − proof by contradiction − suppose Π2 is decidable − then using this reduction we can decide Π1 − this is a contradiction since Π1 is undecidable, therefore Π2 cannot be decidable 75 The halting problem - Undecidability A formal definition of the halting problem (HP) Instance: a legal Java program X and an input string S for X − can substitute any language for Java Question: does X halt when run with input S? Theorem: HP is undecidable proof (by contradiction): − suppose we have an algorithm A that decides (solves) HP − let Q be an implementation of this algorithm as a Java method with X and S as parameters 76 output:\"yes\" output:\"no\" yes no program X input string S Q does X halt on S? The halting problem - Undecidability Define a new program P with input a legal program W in Java − P makes a copy of W and calls Q(W,W) − Q terminates by assumption, returning either \"yes\" or \"no\" − if Q returns \"yes\", then P enters an infinite loop − if Q returns ”no\", then P terminates 77 while (true) null;yes no input program W input string W Q does W halt on W? program W exit program P(W) The halting problem - Undecidability Define a new program P with input a legal program W in Java Now let the input W be the program P itself 78 while (true) null;yes no input program W input string W Q does W halt on W? program W exit program P(W) Define a new program P with input a legal program W in Java Now let the input W be the program P itself The halting problem - Undecidability 79 while (true) null;yes no input program W input string W Q does W halt on W? program W exit program P(W) while (true) null;yes no input program P input string P Q does P halt on P? program P exit program P(P) The halting problem - Undecidability Now let the input W to P be the program P itself P calls Q(P,P) − Q terminates by assumption, returning either \"yes\" or \"no\" − recall we have assumed Q solves the halting problem 80 while (true) null;yes no input program P input string P Q does P halt on P? program P exit program P(P) The halting problem - Undecidability Now let the input W to P be the program P itself P calls Q(P,P) − Q terminates by assumption, returning either \"yes\" or \"no\" − recall we have assumed Q solves the halting problem − suppose Q returns \"yes\", then by definition of Q this means P terminates − but this also means P does not terminate (it enters the infinite loop) • this is a contradiction: P terminates and P does not terminate! − therefore Q can’t return \"yes\" and must return \"no\" 81 while (true) null;yes no input program P input string P Q does P halt on P? program P exit program P(P) The halting problem - Undecidability Now let the input W to P be the program P itself P calls Q(P,P) − Q terminates by assumption, returning either \"yes\" or \"no\" − recall we have assumed Q solves the halting problem − therefore Q must return \"no\" − this means by definition of Q that P does not terminate − but this also means P does terminate by construction with an exit − so again a contradiction 82 while (true) null;yes no input program P input string P Q does P halt on P? program P exit program P(P) The halting problem - Undecidability Now let the input W to P be the program P itself P calls Q(P,P) − Q terminates by assumption, returning either \"yes\" or \"no\" − recall we have assumed Q solves the halting problem − therefore Q can return neither \"yes\" nor \"no\" − meaning no such program Q can exist − if no such Q can exist, then no algorithm can solve the halting problem − hence the problem is undecidable 83 while (true) null;yes no input program P input string P Q does P halt on P? program P exit program P(P) The halting problem - Undecidability To summarise the proof − we assumed the existence of an algorithm A that solved HP − implemented this algorithm as the program Q − then constructed a program P which contains Q as a subroutine − showing that if Q gives the answer \"yes\", we reach a contradiction − so Q must give the answer \"no\", but this also leads to a contradiction − the contradiction stems from assuming that Q, and hence A, exists − therefore no algorithm A exists and HP is undecidable Notice we are not concerned with the complexity of A, just the existence of A 84","libVersion":"0.3.2","langs":""}