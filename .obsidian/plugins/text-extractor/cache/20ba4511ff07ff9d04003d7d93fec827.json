{"path":"university/year 2/semester 1/Practical Algorithms/Slides/4. Sequences, Induction and Recursion/Recursion.pdf","text":"Recursive Algorithms Recursion Is when a function makes a call to itself. We keep defining the problem as simpler versions of itself, until we get to the base case. It works only if: + There is a base case defined. + Parameters to the function on successive calls change (towards the base case). Recursive algorithms: a classic example ‚Ä¢ The factorial function ùëõ! = ùëõ ‚ãÖ ùëõ ‚àí 1 ‚ãÖ ùëõ ‚àí 2 ‚ãÖ ‚Ä¶ ‚ãÖ 1 ‚Ä¢ The above is a recursive algorithm implementation of the factorial ‚àí Repeated calls to FACTORIAL( ), each time applied on a smaller number, are nested ‚àí Until a stopping case (ùëõ = 1) is reached FACTORIAL(n) if n = 1 return 1 else return n * FACTORIAL(n-1) https://freesvg.org/factorial Recursive algorithms: Binary Search Trees ‚Ä¢ Recall: ‚àí BSTs are essentially recursive data structures ‚Ä¢ So, ‚àí The algorithms for operations on them can be defined recursively in a natural way ‚àí However, recall that alternative iterative implementations exist (and can be more efficient!) Finally, some real code! ‚Ä¢ Let‚Äôs looks at factorial code in Python (moodle chapter for this topic) This Photo by Unknown Author is licensed under CC BY-NC-ND General principles for recursive algorithms When calling itself, a recursive function makes a clone and calls the clone with appropriate parameters ‚Ä¢ Rule 1: reduce the size of the input, each time it is recursively called ‚Ä¢ Rule 2: provide a stopping case (terminating condition) A recursive algorithm must always Writing Recursive Functions ‚Äì Tips ‚Ä¢ Write the base case first ‚Ä¢ For the rest of the cases, work out how to ‚Äúreduce‚Äù them to simpler cases ‚û¢ Arguments/input should ‚Äúconverge‚Äù towards the base case ‚Ä¢ Think/visualize in terms of small problem sizes (e.g. FACTORIAL(3)) ‚àí Confirm that the base case works ‚àí Confirm that these specific, small non-base-case cases work ‚àí ‚ÄúConvince‚Äù yourself that generalizing to arbitrary input sizes will work!Review this section from the book: http://openbookproject.net/thinkcs/python/english3e/recursion.html def factorial(x): if x==1: return 1 # stop, it's 1 else: return x * factorial(x-1) Recursion TracesRecursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(2) FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(2) FACT(1)FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(2) FACT(1) return 1 FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(2) FACT(1) return 1 return 2 * 1 = 2 FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(2) FACT(1) return 1 return 2 * 1 = 2 return 3 * 2 = 6 FACT(n) if n = 1 return 1 else return n * FACT(n-1) Recursion trace ‚Ä¢ Graphical method to visualise the execution of recursive algorithms ‚Ä¢ Drawn as follows: ‚àí A box for each recursive call ‚àí An arrow from each caller to callee (in black) ‚àí An arrow from each callee to caller showing return value (in blue) (we will often omit this) ‚Ä¢ Example with FACT(4) FACT(4) FACT(3) FACT(2) FACT(1) return 1 return 2 * 1 = 2 return 3 * 2 = 6 return 4 * 6 = 24 FACT(n) if n = 1 return 1 else return n * FACT(n-1) LINEAR AND BINARY RECURSION Linear recursion ‚Ä¢ At most one recursive call at each invocation ‚Ä¢ The amount of space needed, to keep track of all nested calls, grows linearly (wrt the size of the input) ‚Ä¢ The recursion trace is a visualization of space requirements ‚Ä¢ Example: FACTORIAL(n) ‚àí A single recursive call to FACTORIAL(n-1) FACTORIAL(n) if n = 1 return 1 else return n * FACTORIAL(n-1) FACTORIAL(4) FACTORIAL(3) FACTORIAL(2) FACTORIAL(1) Another example: summing the elements of an array ‚Ä¢ Input: An array A of integers and integer n ÔÇ≥ 1, such that A has at least n elements ‚Ä¢ Output: The sum of the first n integers in A LINEAR-SUM(A,n) Example: sum of array elements ‚Ä¢ Input: An array A of integers and integer n ÔÇ≥ 1, such that A has at least n elements ‚Ä¢ Output: The sum of the first n integers in A ‚Ä¢ Does LINEAR-SUM satisfy our ‚Äúrecursion rules‚Äù? ‚àí Rule 1: input reduced at each recursive call ‚àí Rule 2: valid terminating condition LINEAR-SUM(A,n) if n = 1 then return A[0] else return LINEAR-SUM(A,n-1) + A[n-1] Yes: see 2nd return statement Yes: if statement Sum of array elements: recursion trace ‚Ä¢ Call LINEAR-SUM(A,3) on input A = [1,3,8,6,4,3] LINEAR-SUM(A,n) if n = 1 then return A[0] else return LINEAR-SUM(A,n-1) + A[n-1] LINEAR-SUM(A,3) LINEAR-SUM(A,2) LINEAR-SUM(A,1) return 1 return 1 + 3 = 4 return 4 + 8 = 12 Binary recursionBinary recursion ‚Ä¢ When an algorithm makes two recursive calls, we say that it uses binary recursion ‚àí To solve two halves of some problem ‚Ä¢ Classic example: Fibonacci numbers are a sequence of numbers defined by ‚àí Every number in the sequency is the sum of previous two numbers ‚àí Fn = Fn-1 + Fn-2 for n > 1 with F0 = 0 and F1 = 1 ‚Ä¢ In pseudocode FIB(n) if n ‚â§ 1 // base cases return n else return FIB(n-1) + FIB(n-2) //binary recursion Let‚Äôs get coding ‚Ä¢ yeah yeah yeah... Recursion tree ‚Ä¢ Visualising each recursive call in an algorithm using binary recursion results in a (binary) recursion tree ‚Ä¢ Example for FIB(5) FIB(5) FIB(4) FIB(3) FIB(3) FIB(2) FIB(2) FIB(1)FIB(1) FIB(0) FIB(1) FIB(2) FIB(1) FIB(0) FIB(1) FIB(0) Other BINARY recursive algorithms we have seen already (in the world of Binary Trees) ‚Ä¢ Because: ‚àí ... a binary tree is a recursive data structure (you can define a binary tree in term of smaller binary trees), ‚Ä¢ ...so: ‚àí ...the algorithms for operations on them can often be defined recursively too Tail Recursion Tail recursion ‚Ä¢ Recursion is useful tool for designing algorithms with short, elegant definitions ‚Ä¢ Recursion has a cost ‚àí Need to use memory to keep track of the state of each recursive call (boxes in recursion traces) ‚Ä¢ Overcoming the cost: ‚àí When memory is of primary concern, useful to be able to derive non-recursive algorithms from recursive ones ‚Ä¢ Using iterations (e.g. for or while loops) ‚àí In some cases, we can gain memory efficiency by simply using tail recursion ‚Ä¢ An algorithm uses tail recursion when: ‚àí recursion is linear and ‚àí recursive call is its very last operation each recursive call ‚Ä¢ Less to store for Why Tail Recursion is ‚Äúgood‚Äù (and easy to replace with a loop) Tail Recursion https://en.wikipedia.org/wiki/Tail_call https://www.geeksforgeeks.org/tail-recursion/ Tricks of the trade: Recursion to Iteration, Part 1: The Simple Method, secret features, and accumulators http://blog.moertel.com/posts/2013-05-11-recursive-to- iterative.html Why Tail Recursion is ‚Äúgood‚Äù (and easy to replace with a loop) Tail Recursion https://en.wikipedia.org/wiki/Tail_call https://www.geeksforgeeks.org/tail-recursion/ Tricks of the trade: Recursion to Iteration, Part 1: The Simple Method, secret features, and accumulators http://blog.moertel.com/posts/2013-05-11-recursive-to- iterative.html Example: reversing the elements of an array ‚Ä¢ Input: An array A and integer indices i,j ÔÇ≥ 1 ‚Ä¢ Output: The reversal of the elements in A starting at index i and ending at j ‚Ä¢ Recursive call is the last operation REVERSE-ARRAY(A,i,j) if i < j then SWAP(A[i],A[j]) REVERSE-ARRAY(A,i+1,j-1) Recursion trace ‚Ä¢ For REVERSE-ARRAY(A,0,4) with A = [3,4,6,1,0] ‚Ä¢ Note: No operations performed on the blue (return) arrows ‚àí This is a sign of TAIL RECURSION ‚àí Because there is no operation on the return path, we can easily replace a tail-recursion with loops REVERSE-ARRAY(A,0,4) REVERSE-ARRAY(A,1,3) REVERSE-ARRAY(A,2,2) return return return REVERSE-ARRAY(A,i,j) if i < j then SWAP(A[i],A[j]) REVERSE-ARRAY(A,i+1,j-1) Conversion to non-recursive algorithm ‚Ä¢ Non-recursive algorithm are also called iterative ‚Ä¢ Algorithms using tail recursion can be converted to a non-recursive algorithm by iterating through repeated operations of functions, rather than calling the function again and again explicitly ‚Ä¢ In general, we can always replace recursive algorithm with an iterative one, but often (not always) the recursive solution is shorter and easier to understand ‚Ä¢ Example REVERSE-ARRAY(A,i,j) if i < j then SWAP(A[i],A[j]) REVERSE-ARRAY(A,i+1,j-1) REVERSE-ARRAY-ITER(A,i,j) while i < j SWAP(A[i],A[j]) i := i + 1 j := j - 1 Recursion and Induction RECURSIVE (i.e. INDUCTIVE) DEFINTIONS A Common PatternHave you noticed? ‚Ä¢ Recall: Recursion in Functions ‚àí Define a function in terms in a way that it calls itself, while every time moving towards a smaller problem size ‚àí Define a stopping case where the function is defined directly, without any recursive calls. Have you noticed? ‚Ä¢ Recall: Recursion in Functions ‚àí Define a function in terms in a way that it calls itself, while every time moving towards a smaller problem size ‚àí Define a stopping case where the function is defined directly, without any recursive calls. ‚Ä¢ Recall: Sequences defined via Recurrence Relations ‚àí We specify the first (or first few elements), and then ‚àí Define a recurrence relation on how to calculate subsequent terms using previous terms. Have you noticed? ‚Ä¢ Recall: Recursion in Functions ‚àí Define a function in terms in a way that it calls itself, while every time moving towards a smaller problem size ‚àí Define a stopping case where the function is defined directly, without any recursive calls. ‚Ä¢ Recall: Sequences defined via Recurrence Relations ‚àí We specify the first (or first few elements), and then ‚àí Define a recurrence relation on how to calculate subsequent terms using previous terms. ‚Ä¢ Mathematical Induction: ‚àí Prove something for a base case ‚àí Prove that you can go from a generic case P(k) to its next one, P(k+1)","libVersion":"0.3.2","langs":""}