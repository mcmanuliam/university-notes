{"path":"university/year 2/semester 2/Algorithmics/Slides/5. Computability/5.2 Computability Part 2.pdf","text":"Algorithmics Dr. Oana Andrei School of Computing Science University of Glasgow oana.andrei@glasgow.ac.uk Algorithmics 2025 Lecture 11 Section 5 - Computability Introduction Models of computation − finite-state automata – regular languages and regular expressions − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 2 Computability recap What is a computer? What can the black box do? − it computes a function that maps an input to an output Computability concerned with which functions can be computed − a formal way of answering ‘which problems can be solved by a computer?’ − or alternatively ‘which problems cannot be solved by a computer?’ To answer such questions we require a formal definition − i.e. a definition of what a computer is − alternatively of what an algorithm is if we view a computer as a device that can execute an algorithm 3 Black boxinput x output f(x) Deterministic finite-state automata recap Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ – i.e. symbols on the read-only tape − a finite set of states Q – i.e. memory − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q • ((q,a),q’) ∈ T means if in state q and read a, then move to state q’ 4 Deterministic finite-state automata recap Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q • ((q,a),q’) ∈ T means if in state q and read a, then move to state q’ 5 q0 q2 aa a b q3q1 a,b b b control/program ((q0,a), q1) ((q0,b), q3) ((q1,a), q1) ((q1,b), q2) ((q2,a), q3) ((q2,b), q2) ((q3,a), q3) ((q3,b), q3) add input tape (finite sequence of elements/actions from the alphabet) Deterministic finite-state automata recap Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q • ((q,a),q’) ∈ T means if in state q and read a, then move to state q’ 6 q0 q2 aa a b q3q1 a,b b b control/program ((q0,a), q1) ((q0,b), q3) ((q1,a), q1) ((q1,b), q2) ((q2,a), q3) ((q2,b), q2) ((q3,a), q3) ((q3,b), q3) add input tape (finite sequence of elements/actions from the alphabet) Deterministic finite-state automata recap Simple machines with limited memory which recognise input on a read-only tape A DFA consists of − a finite input alphabet Σ − a finite set of states Q − a initial/start state q0 ∈ Q and set of accepting states F ⊆ Q − control/program or transition relation T ⊆ (Q × Σ) × Q • ((q,a),q’) ∈ T means if in state q and read a, then move to state q’ 7 q0 q2 aa a b q3q1 a,b b b control/program ((q0,a), q1) ((q0,b), q3) ((q1,a), q1) ((q1,b), q2) ((q2,a), q3) ((q2,b), q2) ((q3,a), q3) ((q3,b), q3) add input tape (finite sequence of elements/actions from the alphabet)Recognises strings that start and end with b However this is not a DFA, but a non-deterministic finite-state automaton (NFA) − in state q1 under b can move to q1 or q2 Recognition for NFA is similar to non-deterministic algorithms “solving” a decision problem − only require there exists a ‘run’ that ends in an accepting state − i.e. under one possible resolution of the nondeterministic choices the input is accepted Another example 8 q2 b b q1q0 b q2q1q0 b b b a Another example Recognises strings that start and end with b However this is not a DFA, but a non-deterministic finite-state automaton (NFA) − in state q1 under b can move to q1 or q2 But any NFA can be converted into a DFA Therefore non-determinism does not expand the class of languages that can be recognised by finite state automata − being able to guess does not give us any extra power 9 q2 b b q1q0 b q2q1q0 b a DFAs and languages A (formal) language with alphabet Σ is a set of words over Σ − a word over Σ is a sequence of symbols taken from Σ − a word w over Σ is recognised or accepted by a finite-state automaton with alphabet Σ if the the automaton reaches an accepting state when started in the initial state on the tape that contains the word w The languages that can be recognised by finite-state automata are called the regular languages 10 Regular languages and regular expressions The languages that can be recognised by finite-state automata are called the regular languages A regular language (over an alphabet Σ) can be specified by a regular expression over Σ − ε (the empty string) is a regular expression − σ is a regular expression (for any single character σ∈Σ) if R and S are regular expressions, then so are − RS which denotes concatenation − R | S which denotes choice between R or S − R* which denotes 0 or more copies of R (sometimes called closure) − (R) bracketing is sometimes needed to override precedence between operators 11 Regular expressions Order of precedence (highest first) − closure (*) then concatenation then choice (|) − with brackets used to override this order Example: suppose Σ = {a,b,c,d} − R = (ac|a*b)d means ( ( ac ) | ( (a*) b ) ) d − corresponding language LR is {acd, bd, abd, aabd, aaabd, aaaabd, … } 12 Regular expressions Order of precedence (highest first) − closure (*) then concatenation then choice (|) − with brackets used to override this order Example: suppose Σ = {a,b,c,d} − R = (ac|a*b)d means ( ( ac ) | ( (a*) b ) ) d − corresponding language LR is {acd, bd, abd, aabd, aaabd, aaaabd, … } 13 Regular expressions Order of precedence (highest first) − closure (*) then concatenation then choice (|) − with brackets used to override this order Example: suppose Σ = {a,b,c,d} − R = (ac|a*b)d means ( ( ac ) | ( (a*) b ) ) d − corresponding language LR is {acd, bd, abd, aabd, aaabd, aaaabd, … } 14 Regular expressions Order of precedence (highest first) − closure (*) then concatenation then choice (|) − with brackets used to override this order Example: suppose Σ = {a,b,c,d} − R = (ac|a*b)d means ( ( ac ) | ( (a*) b ) ) d − corresponding language LR is {acd, bd, abd, aabd, aaabd, aaaabd, … } 15 Regular expressions Order of precedence (highest first) − closure (*) then concatenation then choice (|) − with brackets used to override this order Example: suppose Σ = {a,b,c,d} − R = (ac|a*b)d means ( ( ac ) | ( (a*) b ) ) d − corresponding language LR is {acd, bd, abd, aabd, aaabd, aaaabd, … } Additional operations − complement ¬x • equivalent to the 'or' of all characters in Σ except x − any single character ? • equivalent to the 'or' of all characters 16 Regular expressions Regular expressions (regex or regexp) have an important role in CS applications especially those involving text − i.e. searching for strings that satisfy certain patterns − search engines, text editors, word processors − e.g. text processing utilities in Unix such as awk, grep, sed • the IEEE POSIX standard for basic regular expression syntax − built into the syntax of Perl − supported by standard libraries of programming languages • e.g. Python, Java, JavaScript, C++, C#, etc. 17 Regular expressions - Examples The examples from previous lecture over {a,b} 1) the language comprising one or more a's followed by one or more b’s − aa*bb* 2) the language of strings containing two consecutive a’s − (a|b)*aa(a|b)* 18 q0 q2 aa a b q3q1 a,b b b q0 q2 a b b q1 a,b a Regular expressions - Examples The examples from previous lecture over {a,b} 3) the language of strings that do not contain two consecutive a’s − b*(abb*)*(ε|a) 4) the language of strings that start and end with b − b(a|b)*b 19 q2 a b b a,b a q1q0 q2 b b q1q0 b a Regular expressions - Closure To clarify what R* means − corresponds to 0 or more copies of the regular expression R Let L(R) be the language corresponding to the regular expression R − then concatenation is given by L(RS) = { rs | r∈L(R) and s∈L(S) } and L(R*) = L(R0) ∪ L(R1) ∪ L(R2)… where L(R0) = {ε} and L(Ri+1) = L(RRi) − for example: ab, aab ∈ L(a*b*), and hence abaab ∈ L((a*b*)*) 20 Regular expressions - Closure To clarify what R* means − corresponds to 0 or more copies of the regular expression R Let L(R) be the language corresponding to the regular expression R − then concatenation is given by L(RS) = { rs | r∈L(R) and s∈L(S) } and L(R*) = L(R0) ∪ L(R1) ∪ L(R2)… where L(R0) = {ε} and L(Ri+1) = L(RRi) − note (a*b*)* is in fact equivalent to (a|b)* L(R*) does not mean { r* | r ∈ L(R) } − not zero or more copies of one element from L(R) − but zero or more copies where each copy can be anything from L(R) − for certain regular expressions cannot be recognized by any DFA − essentially for such a language would need a memory to remember which string in r∈L(R) is repeated and there might be an unbounded number 21 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 22 b a b q1 b a q3 a,b q2 a q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 23 b a b q1 b a q3 a,b q2 a a b a a b b a b q1 b a q3 a,b q2 a q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 24 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 25 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 26 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 27 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 28 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 29 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 30 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 31 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 32 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example Consider the language (aa*bb*)* − i.e. zero or more sequences which consist of a non-zero number of a’s followed by a non-zero number of b’s Corresponding DFA: 33 b a b q1 b a q3 a,b q2 a a b a a b q0 Regular expressions - Example A DFA cannot recognise { r* | r ∈ L(aa*bb*) } − i.e. { (ambn)* | m > 0 and n > 0 } − the problem is the DFA would need to remember the m and n to check that a string is in the langauge − but there are infinitely many values for m and n − hence the DFA would need infinitely many states − and we only have a finite number (DFA = deterministic finite automaton) Similarly a DFA cannot recognise { anbn | n > 0 } − i.e. a number of a's followed by the same number of b’s Languages that are recognised by DFAs are called regular languages so, for example { anbn | n > 0 } is not regular 34 Regular expressions - Example How can we recognising strings of the form anbn? − i.e. a number of a's followed by the same number of b's It turns out that there is no DFA that can recognise this language − it cannot be done without some form of memory, e.g. a stack Idea: as you read a’s, push them onto a stack, then pop the stack as you read b’s, i.e. the stack works like a counter So there are some functions (languages) that we would regard as computable that cannot be computed by a finite-state automaton − DFAs are not an adequate model of a general-purpose computer i.e. our 'black box’ Pushdown automata extend finite-state automata with a stack 35 Section 5 - Computability Introduction The halting problem Models of computation − finite-state automata − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 36 Why extending DFAs A deterministic finite-state automaton (DFA) cannot recognise the language { anbn | n ≥ 0 } − i.e. a number of a's followed by the same number of b’s − the problem is the DFA would need to remember n to check that a string is in the language − but there are infinitely many values for n − hence the DFA would need infinitely many states and we only have a finite number 37 Why extending DFAs How can we recognising strings of the form anbn? − i.e. a number of a's followed by the same number of b's − it cannot be done without some form of memory, e.g. a stack Idea: as you read a’s, push symbols onto a stack, then pop the stack as you read b’s, i.e. the stack works like a counter So there are some functions (languages) that we would regard as computable that cannot be computed by a finite-state automaton − finite-state automata are not an adequate model of a general-purpose computer i.e. our 'black box’ Pushdown automata extend finite-state automata with a stack 38 Pushdown automata A pushdown automaton (PDA) consists of: − a finite input alphabet Σ, a finite set of stack symbols G (same or different) − a finite set of states Q including start state and set of accepting states − control or transition relation T ⊆ (Q×Σ{ε}×G{ε}) × (Q×G{ε}) 39 current state new state tape symbol or ε old stack symbol or ε new stack symbol or ε a b a b a v w head top tape stackcontrol ε – empty string Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that Pushdown automata 40 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 Pushdown automata 41 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 − if a≠ε, then the symbol a is at the head of the tape Pushdown automata 42 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 − if a≠ε, then the symbol a is at the head of the tape − if w≠ε, then the symbol w is is on top of the stack Pushdown automata 43 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 − if a≠ε, then the symbol a is at the head of the tape − if w≠ε, then the symbol w is is on top of the stack − then move to state q2 and Pushdown automata 44 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 − if a≠ε, then the symbol a is at the head of the tape − if w≠ε, then the symbol w is is on top of the stack − then move to state q2 and − if a≠ε, then move head forward one position • i.e. we have read the symbol a from the head of the tape Pushdown automata 45 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 − if a≠ε, then the symbol a is at the head of the tape − if w≠ε, then the symbol w is is on top of the stack − then move to state q2 and − if a≠ε, then move head forward one position − if w≠ε, then pop w from the stack • a requirement was that w is on the top of the stack Pushdown automata 46 a b a b a v w head top tape stack control Transition relation T ⊆ (Q × Σ{ε} × G{ε}) × (Q × G{ε}) Informally, the transition (q1,a,w) ➝ (q2,v) means that − if we are in state q1 − if a≠ε, then the symbol a is at the head of the tape − if w≠ε, then the symbol w is is on top of the stack − then move to state q2 and − if a≠ε, then move head forward one position − if w≠ε, then pop w from the stack − if v≠ε, then push v onto the stack Pushdown automata 47 a b a b a v w head top tape stack control Pushdown automata A PDA accepts an input if and only if after the input has been read, the stack is empty and control is in an accepting state Example tuples from a PDA program when in state q1 − (q1,ε,ε)➝(q2,ε) move to q2 − (q1,a,ε)➝(q2,ε) if head of tape is a, move to q2 & move head forward − (q1,a,ε)➝(q2,v) if head of tape is a, move to q2, move head forward & push v onto stack − (q1,a,w)➝(q2,ε) if head of tape is a & w is top stack, move to q2, move head forward & pop w from stack − (q1,a,w)➝(q2,v) if head of tape is a & w is top of stack, move to q2, move head forward, pop w & push v onto stack 48 There is no explicit test that the stack is empty − this can be achieved by adding a special symbol ($) to the stack at the start of the computation − i.e. we add the symbol to the stack when we know the stack is empty and we never add $ at any other point during the computation • unless we pop it from the stack as at this point we again know its empty − then can check for emptiness by checking $ is on top of the stack − when we want to finish in an accepting state we just need to make sure we pop $ from the stack (we will see this in an example later) Pushdown automata 49 Pushdown automata Note PDA defined here are non-deterministic (NDPDA) − deterministic PDAs (DPDAs) are less powerful − this differs from DFAs where non-determinism does not add power − i.e. there are languages that can be recognised by a NDPDA but not by a DPDA, e.g. the language of palindromes • palindromes: strings that read the same forwards and backwards 50 Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 51 Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 52 abcdeedcba Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 53 abcdeedcba abcde edcba Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 54 abcdeedcbaabcdeedcba Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 55 abcdeedcbaabcdeedcba Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 56 abcde edcbaf Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 57 abcde edcbaabcde edcbaf f Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 58abcdeedcbaabcde edcbaf f Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed 59abcdeedcbaabcde edcbaf f Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed Why do we need non-determinism? − we need to “guess” where the middle of the stack is • and if there are even or odd number of characters − cannot work this out first and then check the string as would need • to read the string twice (as only have a stack) • an unbounded number of states as the string could be of any finite length 60 Pushdown automata - Palindromes Palindromes are sequences of characters that read the same forwards and backwards (second half is the reverse of the first half) How to recognize palindromes with a pushdown automaton? − push the first half of the sequence onto the stack − then as we read each new character check it is the same as the top element on the the stack and pop this element − then enter an accepting state if all checks succeed Why do we need non-determinism? − we need to “guess” where the middle of the stack is • and if there are even or odd number of characters − cannot work this out first and then check the string as would need • to read the string twice (as only have a stack) • an unbounded number of states as the string could be of any finite length 61 Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 62 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε (empty) stack a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 63 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε (empty) stack a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 64 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε (empty) stack a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 65 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack $ a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 66 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stacka a b b head tape $ Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 67 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack $ 1 a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 68 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack $ 1 a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 69 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack 1 head tape $ 1 a a b b Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 70 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack 1 head tape $ 1 a a b b Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 71 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack head tape $ 1 a a b b Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 72 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack head tape $ 1 a a b b Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 73 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack head tape $ a a b b Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 74 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε stack head tape $ a a b b Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 75 q1 ε,ε➝$ q0 q3 a,ε➝1 b,1➝ε q2 b,1➝ε ε,$➝ε (empty) stack a a b b head tape Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 Example inputs − if you try to recognise aabb, all of the input is read, as we have just seen end up in an accepting state, and the stack is empty − if you try to recognise aaabb, all the input is read, you end up in state q2 and the stack in not empty − if you try to recognise aabbb, you are left with b on the tape, which cannot be read because of an empty stack 76 Pushdown automata - Example Consider the following PDA program (alphabet is {a,b}) − q0 is the start state and q0 and q3 are the only accepting states − (q0,ε,ε)➝(q1,$) move to q1 and push $ onto stack ($ - special symbol) − (q1,a,ε)➝(q1,1) read a & push 1 onto stack − (q1,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack & move to q2 − (q2,b,1)➝(q2,ε) read b & 1 is top of stack, pop stack − (q2,ε,$)➝(q3,ε) if $ is the top of the stack, pop stack & move to q3 Automaton recognises the language: { anbn | n ≥ 0 } 77 Pushdown automata Pushdown automata are more powerful than finite-state automata − a PDA can recognise some languages that cannot be recognised by a DFA − e.g. {anbn | n ≥ 0} is recognised by the PDA example The languages that can be recognised by a PDA are the context-free languages Are all languages regular or context-free? i.e. is a PDA an adequate model of a general-purpose computer (our 'black box')? No, for example, consider the language {anbncn | n ≥ 0} − this cannot be recognised by a PDA − but it is easy to write a program (say in Java) to recognise it − next lecture – Turing machines as general model of a computer 78 Applications of DFAs & PDAs 79 Theoretical − understanding computability and complexity − formal specification of software behaviour and verifying properties Practical applications in software development − DFAs - design compilers and interpreters, lexical analysis − regexp - string matching and validation − DFAs – modelling and analysing communication protocols as finite state machines in embedded systems, network protocols, user interfaces − context-free grammars/CFGs (which generate context-free languages/CFLs) used for defining the syntactic structure of programming languages – useful for designing new programming languages − CFGs are used for data interchange formats like JSON and XML (nested structures) Computational thinking skills, problem-solving Hierarchy of grammars and automata 80 Regular Languages (type 3) − grammar: Regular Grammars − automaton: Finite Automata (FA) - both Deterministic (DFA) and Non- deterministic (NFA) Context-Free Languages (type 2) − grammar: Context-Free Grammars (CFG) − automaton: Pushdown Automata (PDA) Context-Sensitive Languages (type 1) − grammar: Context-Sensitive Grammars (CSG) − automaton: Linear Bounded Automaton (LBA) Recursively Enumerable Languages (type 0) − grammar: Unrestricted Grammars − automaton: Turing Machine (TM) - both Deterministic (DTM) and Non- deterministic (NTM) Chomsky hierarchy introduced in the 1950’s by Noam Chomsky https://en.wikipedia.org/wiki/Chomsky_hierarchy Next time - Section 5 - Computability Introduction Models of computation − finite-state automata – regular languages and regular expressions − pushdown automata − Turing machines − Counter machines − Church-Turing thesis 81","libVersion":"0.3.2","langs":""}