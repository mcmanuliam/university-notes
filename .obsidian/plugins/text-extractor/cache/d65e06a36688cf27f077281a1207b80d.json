{"path":"university/year 2/semester 2/Algorithmics/Slides/2. Strings and Text algorithms/2.3. Pattern searching.pdf","text":"Algorithmics Dr. Oana Andrei School of Computing Science University of Glasgow oana.andrei@glasgow.ac.uk GA Algorithmics 2025 Lecture 4 Section 2 – Strings and text algorithms Text compression − Huffman encoding − LZW compression/decompression String comparison − string distance String/pattern search − brute force algorithm − KMP algorithm − BM algorithm 2 String search – Brute force algorithm Worst case is no better than O(mn) − e.g. search for s = aa … ab in t = aa ... aaaa … ab − m character comparisons needed at each n–(m+1) positions in the text before the text/pattern is found Typically, the number of comparisons from each point will be small − often just 1 comparison needed to show a mismatch − so we can expect O(n) on average Challenges: can we find a solution that is… 1. linear, i.e. O(m+n) in the worst case? 2. (much) faster than brute force on average? 3 length m length n String search – KMP algorithm The Knuth-Morris-Pratt (KMP) algorithm − addresses first challenge: linear (O(m+n)) in the worst case 4 About Donald Knuth Known as the “father of the analysis of algorithms” Recipient of the ACM Turing Award in 1974 (aka Nobel Prize of Computer Science) Honorary degree from the University of Glasgow 2011 Wrote “The Art of Computer Programming” − volumes 1-7 − when type setting he came up with TeX - the predecessor or LaTeX 5 Credit photo: blog.typekit.com Extra: https://cacm.acm.org/news/175194-twenty-questions-for-donald-knuth String search – KMP algorithm The Knuth-Morris-Pratt (KMP) algorithm − addresses first challenge: linear (O(m+n)) in the worst case It is an on-line algorithm − i.e., it removes the need to back-up in the text − involves pre-processing the string to build a border table − border table: an array b with entry b[j] for each position j of the string If we get a mismatch at position j in the string/pattern − we remain on the current text character (do not back-up) − the border table tells us which string character should next be compared with the current text character 6 String search – KMP algorithm A substring of string s is a sequence of consecutive characters of s − if s has length n, then s[i..j] is a substring for i and j with 0≤i≤j≤n-1 A prefix of s is a substring that begins at position 0 − i.e. s[0..j] for any j with 0≤j≤n-1 A suffix of s is a substring that ends at position n-1 − i.e. s[i..n-1] for any i with 0≤i≤n-1 A border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself − e.g. s = a c a c g a t a c a c − a c and a c a c are borders 7 String search – KMP algorithm A substring of string s is a sequence of consecutive characters of s − if s has length n, then s[i..j] is a substring for i and j with 0≤i≤j≤n-1 A prefix of s is a substring that begins at position 0 − i.e. s[0..j] for any j with 0≤j≤n-1 A suffix of s is a substring that ends at position n-1 − i.e. s[i..n-1] for any i with 0≤i≤n-1 A border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself − e.g. s = a c a c g a t a c a c − a c and a c a c are borders 8 String search – KMP algorithm A substring of string s is a sequence of consecutive characters of s − if s has length n, then s[i..j] is a substring for i and j with 0≤i≤j≤n-1 A prefix of s is a substring that begins at position 0 − i.e. s[0..j] for any j with 0≤j≤n-1 A suffix of s is a substring that ends at position n-1 − i.e. s[i..n-1] for any i with 0≤i≤n-1 A border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself − e.g. s = a c a c g a t a c a c − a c and a c a c are borders 9 String search – KMP algorithm A substring of string s is a sequence of consecutive characters of s − if s has length n, then s[i..j] is a substring for i and j with 0≤i≤j≤n-1 A prefix of s is a substring that begins at position 0 − i.e. s[0..j] for any j with 0≤j≤n-1 A suffix of s is a substring that ends at position n-1 − i.e. s[i..n-1] for any i with 0≤i≤n-1 A border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself − e.g. s = a c a c g a t a c a c − a c and a c a c are borders and a c a c is the longest border 10 String search – KMP algorithm A substring of string s is a sequence of consecutive characters of s − if s has length n, then s[i..j] is a substring for i and j with 0≤i≤j≤n-1 A prefix of s is a substring that begins at position 0 − i.e. s[0..j] for any j with 0≤j≤n-1 A suffix of s is a substring that ends at position n-1 − i.e. s[i..n-1] for any i with 0≤i≤n-1 A border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself − e.g. s = a c a c g a t a c a c − a c and a c a c are borders and a c a c is the longest border Many strings have no border − we then say that the empty string ε (of length 0) is the longest border 11 String search – Border table KMP algorithm requires the border table of the string/pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − no common prefix/suffix of empty string (when j=0) so set b[0] to 0 12 b a b a c aastring/pattern s 0 0 j b[j] String search – Border table KMP algorithm requires the border table of the string pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − no common prefix/suffix of a (no border for single-char string), so b[i] is set to 0 13 b a b a c aastring/pattern s 1 0 0 0 j b[j] String search – Border table KMP algorithm requires the border table of the string pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − no common prefix/suffix of ab so set to 0 14 b a b a c aa 1 0 0 0 2 0 j b[j] string/pattern s String search – Border table KMP algorithm requires the border table of the string pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − a is the longest prefix and suffix of aba 15 b a b a c aa 1 0 0 0 2 0 3 1 j b[j] string/pattern s String search – Border table KMP algorithm requires the border table of the string pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − ab is the longest prefix and suffix of abab 16 b a b a c aa 1 2 3 40j 0 0 10 2b[j] string/pattern s String search – Border table KMP algorithm requires the border table of the string pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − aba is the longest prefix and suffix of ababa 17 b a b a c aa 1 2 3 4 0 0 1 0 0 2 5 3 j b[j] string/pattern s String search – Border table KMP algorithm requires the border table of the string pattern − a border of a string s is a substring that is both a prefix and a suffix and cannot be the string itself Border table b: array which has the same size as the string − b[j] = the length of the longest border of s[0..j-1] = max { k | s[0..k-1] = s[j-k..j-1] ∧ k<j } Example − no common prefix/suffix of ababac so set to 0 18 b a b a c aa 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 string/pattern s Example - Mismatch between s and t at position 9 in s Applying the brute force algorithm, after the mis-match: − s has to be ‘moved along’ one position relative to t String search – Brute force versus KMP 19 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the brute force algorithm, after the mis-match: − s has to be ‘moved along’ one position relative to t String search – Brute force versus KMP 20 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the brute force algorithm, after the mis-match: − s has to be ‘moved along’ one position relative to t − then we start again at position 0 in s and jump back j-1 positions in t String search – Brute force versus KMP 21 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … jnew inew i j Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match String search – Brute force versus KMP 22 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … i j Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match String search – Brute force versus KMP 23 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … i j Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match String search – Brute force versus KMP 24 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … i j Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match String search – Brute force versus KMP 25 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … i j Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match String search – Brute force versus KMP 26 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match − this determines the new value of j, the value of i is unchanged String search – Brute force versus KMP 27 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 a a 10 11 12 13 text t string/pattern s * * * * … jnew i j String search – Brute force versus KMP Need to move s along until the characters to the left of i match − i.e. move s as follows: 28 $ * j i text t string/pattern s … … … s[0..j-1] s[0..j-1] $ *text t string/pattern s … … … mis-match s[0..j-1] s[0..j-1] String search – Brute force versus KMP Need to move s along until the characters to the left of i match − i.e. move s as follows: 29 $ * string/pattern s … … … s[0..j-1] $ * j text t string/pattern s … … … s[0..j-1] s[0..j-1] mis-match i s[0..j-1]text t String search – Brute force versus KMP Need to move s along until the characters to the left of i match − i.e. move s as follows: 30 $ *text t string/pattern s … … … s[0..j-1] $ * j text t string/pattern s … … … s[0..j-1] s[0..j-1] mis-match i s[0..j-1] String search – Brute force versus KMP Need to move s along until the characters to the left of i match therefore need start of s[0..j-1] to match end of s[0..j-1] 31 $ *text t string/pattern s … … … these sub-strings need to match $ * j text t string/pattern s … … … s[0..j-1] s[0..j-1] mis-match i String search – Brute force versus KMP Need to move s along until the characters to the left of i match therefore need start of s[0..j-1] to match end of s[0..j-1] − therefore use longest border of s[0..j-1] − i.e. longest substring that is both a prefix and a suffix of s[0..j-1] 32 $ *text t string/pattern s … … … $ * j text t string/pattern s … … … s[0..j-1] s[0..j-1] mis-match i String search – Brute force versus KMP Need to move s along until the characters to the left of i match therefore need start of s[0..j-1] to match end of s[0..j-1] − therefore use longest border of s[0..j-1] − i.e. longest substring that is both a prefix and a suffix of s[0..j-1] 33 $ *text t string/pattern s … … … $ * j text t string/pattern s … … … s[0..j-1] s[0..j-1] mis-match i String search – Brute force versus KMP Need to move s along until the characters to the left of i match therefore need start of s[0..j-1] to match end of s[0..j-1] − therefore use longest border of s[0..j-1] − i.e. longest substring that is both a prefix and a suffix of s[0..j-1] 34 $ *text t string/pattern s … … … $ * j text t string/pattern s … … … s[0..j-1] s[0..j-1] mis-match i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match − this determines the new value of j, the value of i is unchanged − length of the longest border of s[0..j-1] is 4 in this case • i.e. longest substring that is both a prefix and a suffix of s[0..j-1] − so the new value of j is 4 String search – Brute force versus KMP 35 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g * 0 a a 10 11 12 13 text t string/pattern s * * * * … jnew j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 36 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t t 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 37 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t t 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 38 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t t 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 39 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t t 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 40 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t t 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 41 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g a g c a g a g t 0 t t 10 11 12 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 9 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged String search – Brute force versus KMP 42 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c g a g c a g a g t 0 t t 10 11 text t string/pattern s * * * * … j i jnew Example - Mismatch between s and t at position 0 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged − unless j is already 0 and in this case increment i String search – Brute force versus KMP 43 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t a 10 11 12 13 text t string/pattern s * * * * … j i Example - Mismatch between s and t at position 0 in s Applying the KMP algorithm, after the mis-match: − s has to be ‘moved along’ until the characters to the left of i again match If we cannot move s along to get a match, then we need to − reset j (i.e. return to the start of the string) and i remains unchanged − unless j is already 0 and in this case increment i String search – Brute force versus KMP 44 1 2 3 4 5 6 7 8 9 g a g c a g a g a g c a g g a g c a g a g t 0 t a 10 11 12 13 text t string/pattern s * * * * … j i inew KMP search - Implementation 45 /** return smallest k such that s occurs from position k in t or -1 if no k exists */ public int kmp(char[] t, char[] s) { int m = s.length; // length of string/pattern int n = t.length; // length of text int i = 0; // current position in text int j = 0; // current position in string s int [] b = new int[m]; // create border table setUp(b); // set up the border table while (i <= n) { // not reached end of text if (t[i] == s[j]){ // if positions match i++; // move on in text j++; // move on in string if (j = m) return i – j; // reached end of string so a match } else { // mismatch adjust current position in string using the border table if (b[j] > 0) // there is a common prefix/suffix j = b[j]; // change position in string (position in text unchanged) else { // no common prefix/suffix if (j = 0) i++; // move forward one position in text if not advanced else j = 0; // else start from beginning of the string } } } return -1; // no occurrence } KMP - Example Starting position: − start of text and string 46 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=0 b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 KMP - Example Compare characters in text and string 47 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters do not match − and border table for b[j]=b[0] is 0 − j=0 so increment position text 48 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters do not match − and border table for b[j]=b[0] is 0 − j=0 so increment position text 49 a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string 50 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters match − increment position in text and string 51 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters match − increment position in text 52 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string 53 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=1 KMP - Example Characters do not match − border table for b[j]=b[1] is 0 − j>0 so start again in string 54 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=1 KMP - Example Characters do not match − border table for b[j]=b[1] is 0 − j>0 so start again in string 55 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string 56 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string − and border table for b[j]=b[0] is 0 − j=0 so increment position text 57 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string − and border table for b[j]=b[0] is 0 − j=0 so increment position text 58 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string 59 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters do not match − and border table for b[j]=b[0] is 0 − j=0 so increment position text 60 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters do not match − and border table for b[j]=b[0] is 0 − j=0 so increment position text 61 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Compare characters in text and string 62 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters match − increment position in text and string 63 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=0 KMP - Example Characters match − increment position in text and string 64 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=1 KMP - Example Compare characters in text and string 65 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=1 KMP - Example Characters match − increment position in text and string 66 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=1 KMP - Example Characters continue to match so − increment position in text and string 67 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=2 KMP - Example Characters continue to match so − increment position in text and string 68 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=3 KMP - Example Characters continue to match so − increment position in text and string 69 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=4 KMP - Example Characters do not match − and border table for b[j]=b[5] is 3 − therefore • j set equal to b[j]=3 • position in text unchanged 70 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=5 KMP - Example Characters do not match − and border table for b[j]=b[5] is 3 − therefore • j set equal to b[j]=3 • position in text unchanged 71 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=3 KMP - Example Compare characters in text and string 72 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=3 KMP - Example Characters match − increment position in text and string 73 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=3 KMP - Example Characters continue to match so − increment position in text and string 74 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=4 KMP - Example Characters continue to match so − increment position in text and string 75 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=5 KMP - Example Characters continue to match so − increment position in text and string 76 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=6 KMP - Example String/pattern has been found 77 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b b a b a c aastring/pattern s 1 2 3 4 0 0 1 0 0b[j] j 2 5 3 6 0 position in string j=7 KMP search - Analysis For the complexity we need to know the number of loop iterations Consider values of i and k (where k=i-j) during the iterations − clearly i≤n and since j is never negative we also have k≤n − in each iteration either i or k is incremented and neither is decremented 78 while (i<n) if (t[i] == s[j]){ i++; j++; } else { if (b[j]>0) j = b[j]; else { if (j=0) i++; else j = 0; } } KMP search - Analysis For the complexity we need to know the number of loop iterations Consider values of i and k (where k=i-j) during the iterations − clearly i≤n and since j is never negative we also have k≤n − in each iteration either i or k is incremented and neither is decremented • i++ > i and (i++)-(j++) = i-j 79 while (i<n) if (t[i] == s[j]){ i++; j++; } else { if (b[j]>0) j = b[j]; else { if (j=0) i++; else j = 0; } } KMP search - Analysis For the complexity we need to know the number of loop iterations Consider values of i and k (where k=i-j) during the iterations − clearly i≤n and since j is never negative we also have k≤n − in each iteration either i or k is incremented and neither is decremented • i = i and i-b[j] > i-j • since b[j]<j as b[j] longest border in a string of length j 80 while (i<n) if (t[i] == s[j]){ i++; j++; } else { if (b[j]>0) j = b[j]; else { if (j=0) i++; else j = 0; } } KMP search - Analysis For the complexity we need to know the number of loop iterations Consider values of i and k (where k=i-j) during the iterations − clearly i≤n and since j is never negative we also have k≤n − in each iteration either i or k is incremented and neither is decremented • i++ > i and (i++)-j > i-j 81 while (i<n) if (t[i] == s[j]){ i++; j++; } else { if (b[j]>0) j = b[j]; else { if (j=0) i++; else j = 0; } } KMP search - Analysis For the complexity we need to know the number of loop iterations Consider values of i and k (where k=i-j) during the iterations − clearly i≤n and since j is never negative we also have k≤n − in each iteration either i or k is incremented and neither is decremented • i = i and i-0 > i-j • since j>0 must hold for the else case to be taken 82 while (i<n) if (t[i] == s[j]){ i++; j++; } else { if (b[j]>0) j = b[j]; else { if (j=0) i++; else j = 0; } } KMP search - Analysis For the complexity we need to know the number of loop iterations Consider values of i and k (where k=i-j) during the iterations − clearly i≤n and since j is never negative we also have k≤n − in each iteration either i or k is incremented and neither is decremented − so the number of iterations of the loop is at most 2n Hence KMP is O(n) in the worst case for the search part 83 while (i<n) if (t[i] == s[j]){ i++; j++; } else { if (b[j]>0) j = b[j]; else { if (j=0) i++; else j = 0; } } KMP search - Analysis KMP search is O(n) in the worst case Creating the border table − naïve method requires O(j2) steps to evaluate b[j] giving O(m3) overall • requires testing all possible borders • 1 + 2 + ... + j-1 = (j-1)j/2 = O(j2) operations 84 KMP search - Analysis KMP search is O(n) in the worst case Creating the border table − naïve method requires O(j2) steps to evaluate b[j] giving O(m3) overall − a more efficient method is possible that requires just O(m) steps in total involves a subtle application of the KMP algorithm (details are omitted) Overall complexity of KMP search − KMP can be implemented to run in O(m+n) time − O(m) for setting up the border table − O(n) for conducting the search Have addressed challenge 1 − KMP algorithm is linear (i.e. O(m+n)) 85 Section 2 – Strings and text algorithms Text compression − Huffman encoding − LZW compression/decompression String comparison − string difference String/pattern search − brute force algorithm − KMP algorithm − Boyer-Moore algorithm 86 Boyer-Moore Algorithm Challenge 1: can we find a solution that is linear in the worst case? Yes: KMP Challenge 2: can we find a solution that is (much) faster than brute force on average? Boyer-Moore: almost always faster than brute force or KMP − variants are used in many real-world applications (used in GNU’s grep) − typically, many text characters are skipped without even being checked − the string/pattern is scanned right-to-left − text character involved in a mismatch is used to decide next comparison 87 Boyer-Moore Algorithm – Example 88 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − start by comparing mth element of text with last character of string • m is the length of the string, i.e. equals 4 • i.e. we line them up on their first characters Boyer-Moore Algorithm – Example 89 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − start by comparing 4th element of text with last (4th) character of string Boyer-Moore Algorithm – Example 90 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − start by comparing 4th element of text with last (4th) character of string − ‘l’ and ‘ ’ (space) do not match − since there is no ‘ ’ in the string, we can shift string along by its length i.e. by 4 places Boyer-Moore Algorithm – Example 91 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill Search for string from right to left − start by comparing 4th element of text with last (4th) character of string − ‘l’ and ‘ ’ (space) do not match − since there is no ‘ ’ in the string, we can shift string along by its length i.e. by 4 places Boyer-Moore Algorithm – Example 92 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill Search for string from right to left − start by comparing 4th element of text with last (4th) character of string − ‘l’ and ‘ ’ (space) do not match − since there is no ‘ ’ in the string, we can shift string along by its length i.e. by 4 places Boyer-Moore Algorithm – Example 93 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill Search for string from right to left − start by comparing 4th element of text with last (4th) character of string − ‘l’ and ‘ ’ (space) do not match − since there is no ‘ ’ in the string, we can shift string along by its length i.e. by 4 places Boyer-Moore Algorithm – Example 94 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill Search for string from right to left − start by comparing 4th element of text with last (4th) character of string − ‘l’ and ‘ ’ (space) do not match − since there is no ‘ ’ in the string, we can shift string along by its length i.e. by 4 places Boyer-Moore Algorithm – Example 95 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − start by comparing 4th element of text with last (4th) character of string − ‘l’ and ‘ ’ (space) do not match − since there is no ‘ ’ in the string can shift string along by its length i.e. by 4 places and continue the search from last position in the string Boyer-Moore Algorithm – Example 96 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘l’ and ‘e’ do not match − since there is no ‘e’ in the string, we can again shift string along by its length • i.e. by 4, and continue search from the last position in the string • i.e. we shift the string all the way past ‘e’ in the text Boyer-Moore Algorithm – Example 97 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string Boyer-Moore Algorithm – Example 98 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘l’ matches so continue trying to match right to left Boyer-Moore Algorithm – Example 99 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘i’ and ‘l’ do not match − however there is an ‘i’ in the string so move string along so that the ‘i’s line up Boyer-Moore Algorithm – Example 100 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill Search for string from right to left − continue search from the last position in the string − ‘i’ and ‘l’ do not match − however there is an ‘i’ in the string so move string along so that the ‘i’s line up Boyer-Moore Algorithm – Example 101 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘i’ and ‘l’ do not match − however there is an ‘i’ in the string so move string along so that the ‘i’s line up and continue search from the last position in the string Boyer-Moore Algorithm – Example 102 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘l’ matches so continue trying to match right to left Boyer-Moore Algorithm – Example 103 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘l’ matches so continue trying to match right to left Boyer-Moore Algorithm – Example 104 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘i’ matches so continue trying to match right to left Boyer-Moore Algorithm – Example 105 Search for ‘pill’ in ‘the caterpillar’ the caterpillar pill ^ Search for string from right to left − continue search from the last position in the string − ‘p’ matches and we have found the string in the text Boyer-Moore Algorithm – Simplified version The string is scanned right-to-left − text character involved in a mismatch is used to decide next comparison − involves pre-processing the string to record the position of the last occurrence of each character c in the alphabet − therefore the alphabet must be fixed in advance of the search Last occurrence position of character c in the string s − equals max{ k | s[k]=c } if such a k exists and -1 otherwise Want to store last occurrence position of c in an array element p[c] − but in Java we can not index an array by characters − instead can use the static method Character.getNumericValue(c) − to compute an appropriate array index Simplified version (often called the Boyer–Moore–Horspool algorithm) 106 Boyer-Moore Algorithm – Simplified version In our pseudocode we assume an array p[c] indexed by characters − the characters range over the underlying alphabet of the text − p[c] records the position in the string of the last occurrence of char c − if the character c is absent from the string s, then let p[c]=-1 Assume ASCII character set (128 characters) − for Unicode (more than 107,000 characters), p would be a large array On finding a mismatch there is a jump step in the algorithm − if the mismatch is between s[j] and t[i] − ‘slide s along’ so that position p[t[i]] of s aligns with t[i] • i.e. align last position in s of character t[i] with position i of t − if this moves s in the ‘wrong direction’, instead move s one position right − if t[i] does not appear in string, ‘slide string’ passed t[i] • i.e. align position -1 of s with position i of t 107 Boyer-Moore Algorithm – Jump step case 1 Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text 108 reminder: p[t[i]] records the position in s of the last occurrence of character t[i] . . a . . . b . . * * * * a * * * * * * …text t string/pattern s i jp[t[i]] ** sp Boyer-Moore Algorithm – Jump step case 1 Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text 109 . . a . . . b . . * * * * a * * * * * * …text t string/pattern s i jp[t[i]] ** move s so char at position p[t[i]] is aligned with that of t that was mismatched sp Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 1 110 * * * * a * * * * * * …text t i ** . . a . . . b . . jp[t[i]] sp move s so char at position p[t[i]] is aligned with that of t that was mismatched Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 1 111 * * * a * * * * * * …text t i ** . . a . . . b . . jp[t[i]] * sp move s so char at position p[t[i]] is aligned with that of t that was mismatched Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 1 112 * * * a * * * * * * …text t i ** . . a . . . b . . jp[t[i]] * sp move s so char at position p[t[i]] is aligned with that of t that was mismatched Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 1 113 * * * a * * * * * * …text t i ** . . a . . . b . . jp[t[i]] * sp move s so char at position p[t[i]] is aligned with that of t that was mismatched Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − i records the current position in the text we are checking − new value of i equals i+(m-1)-p[t[i]] Boyer-Moore Algorithm – Jump step case 1 114 * * * * a * * * * * * …text t i ** inew j m-1 p[t[i]] string/pattern s . . a . . . b . . (m-1)-p[t[i]] sp Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − j records the current position in the string we are checking − new value of j equals m-1 (start again from the end of the string/pattern) Boyer-Moore Algorithm – Jump step case 1 115 * * * * a * * * * * * …text t i ** j string/pattern s . . a . . . b . . jnew p[t[i]] sp Assume a mismatch between position s[j] and position t[i] Case 1: the last position of character t[i] in s is before position j − sp records the current starting position of string in the text − new value of sp equals sp+j-p[t[i]] as this is the amount the pattern/ string has been moved forward Boyer-Moore Algorithm – Jump step case 1 116 * * * * a * * * * * * …text t i ** j string/pattern s . . a . . . b . . sp spnew j-p[t[i]] p[t[i]] Boyer-Moore Algorithm – Jump step case 2 Assume a mismatch between position s[j] and position t[i] Case 2: last position of character t[i] in s is at least at position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text 117 * * * * a * * * * * *text t string/pattern s i . . b . . . . . . j …* move string along by one place and start again from the end of the string a p[t[i]] sp Assume a mismatch between position s[j] and position t[i] Case 2: last position of character t[i] in s is at least at position j − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text Boyer-Moore Algorithm – Jump step case 2 118 * * * * a * * * * * *text t string/pattern s i . . b . . . a . . j …* move string along by one place and start again from the end of the string sp Assume a mismatch between position s[j] and position t[i] Case 2: last position of character t[i] in s is at least at position j − i records the current position in the text we are checking − new value of i equals i+(m-1)–(j-1) = i+(m-j) Boyer-Moore Algorithm – Jump step case 2 119 * * * * a * * * * * *text t string/pattern s i . . b . . . a . . j …* inew position m-1 position j-1 (m-1)–(j-1) sp Assume a mismatch between position s[j] and position t[i] Case 2: last position of character t[i] in s is at least at position j − j records the current position in the string we are checking − new value of j equals m-1 Boyer-Moore Algorithm – Jump step case 2 120 * * * * a * * * * * *text t string/pattern s i . . b . . . a . . j …* jnew sp Assume a mismatch between position s[j] and position t[i] Case 2: last position of character t[i] in s is at least at position j − sp records the current starting position of string in the text − new value of sp equals sp+1 Boyer-Moore Algorithm – Jump step case 2 121 * * * * a * * * * * *text t string/pattern s i . . b . . . a . . j …* sp spnew Boyer-Moore Algorithm – Jump step case 3 Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text 122 . . . . . . b . . * * * * a * * * * * * …text t string/pattern s i j ** . * * .* sp Boyer-Moore Algorithm – Jump step case 3 Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text 123 . . . . . . b . . * * * * a * * * * * *text t string/pattern s i j ** . move s past the character that does not appear in the string * * .* … sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 3 124 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … move s past the character that does not appear in the string sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 3 125 * * * * a * * * * * *text t i ** . . . . . . b . . j sp * * .* … move s past the character that does not appear in the string Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 3 126 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … move s past the character that does not appear in the string sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 3 127 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … move s past the character that does not appear in the string sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 3 128 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … move s past the character that does not appear in the string sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − j records the current position in the string we are checking − sp records the current starting position of string in the text string/pattern s Boyer-Moore Algorithm – Jump step case 3 129 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … move s past the character that does not appear in the string sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − new value of i equals i+m string/pattern s Boyer-Moore Algorithm – Jump step case 3 130 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … inew m-1 sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − i records the current position in the text we are checking − new value of i equals i+m string/pattern s Boyer-Moore Algorithm – Jump step case 3 131 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … inew m sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − j records the current position in the string we are checking − new value of j equals m-1 (start again from the end of the string/pattern) string/pattern s Boyer-Moore Algorithm – Jump step case 3 132 * * * * a * * * * * *text t i ** . . . . . . b . . j * * .* … inew jnew sp Assume a mismatch between position s[j] and position t[i] Case 3: character t[i] does not appear in s (i.e. we have p[j]=-1) − sp records the current starting position of string in the text − new value of sp equals sp+(j+1) as this is the amount the pattern/ string has been moved forward string/pattern s Boyer-Moore Algorithm – Jump step case 3 133 * * * * a * * * * * *text t ** . . . . . . b . . j * * .* … inew spnew j+1 sp i Boyer-Moore Algorithm – All cases Case 1: p[t[i]]<j and p[t[i]]≥0 − new value of i equals i+m-1-p[t[i]] − new value of j equals m-1 Case 2: p[t[i]]>j − new value of i equals i+m-j − new value of j equals m-1 − new value of sp equals sp+1 Case 3: p[t[i]]=-1 − new value of i equals i+m − new value of j equals m-1 − new value of sp equals sp+j+1 134 Note p[t[i]] cannot equal j as p[t[i]] last position of character t[i] in s and mismatch between t[i] and s[j] Boyer-Moore Algorithm – All cases We find that we can express these updates as follows: − new value of i equals i + m – min(1+p[t[i]],j) − new value of j equals m-1 − new value of sp equals sp + max(j-p[t[i]],1) You do not need to learn these updates, just how the algorithm works − this is sufficient for running it on an example (as you saw) − and for working out what the updates are if needed (again as you saw) 135 Boyer-Moore Algorithm - Implementation 136 /** return smallest k such that s occurs at k in t or -1 if no k exists */ public int bm(char[] t, char[] s) { int m = s.length; // length of string/pattern int n = t.length; // length of text int sp = 0; // current starting position of string in text int i = m-1; // current position in text int j = m-1; // current position in string/pattern // declare a suitable array p setUp(s, p); // set up the last occurrence array while (sp <= n-m && j >= 0) { if (t[i] == s[j]){ // current characters match i--; // move back in text j--; // move back in string } else { // current characters do not match sp += max(1, j - p[t[i]]); i += m – min(j, 1 + p[t[i]]); j = m-1; // return to end of string } } if (j < 0) return sp; else return -1; // occurrence found yes/no } Boyer-Moore Algorithm - Complexity Worst case is no better than O(mn) − e.g. search for s = ba … aa in t = aa … aaaa … aa − m character comparisons needed at each n–(m+1) positions in the text before the text/pattern is found − start from the right and all matches until we get to b − since the last occurrence comes afterwards, only shift by one position each time − we end up doing the same number of operations at each step − hence worst case behaviour similar to brute force There is an extended version which is linear, i.e. O(m+n) − this uses “the good suffix rule” – look it up yourselves 137 length m length n Boyer Moore - Example Starting position: − start of text and end of string 138 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Compare characters in text and string 139 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Characters match − decrement position in text and string 140 position in string j=6 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters match − decrement position in text and string 141 position in string j=5 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Compare characters in text and string 142 position in string j=5 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters do not match − case 1: the last position of character b in s is before position j − move s so last b in s is aligned with that of t that was mismatched − and start comparisons from end of the string 143 position in string j=5 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters do not match − case 1: the last position of character b in s is before position j − move s so last b in s is aligned with that of t that was mismatched − and start comparisons from end of the string 144 position in string j=6 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Compare characters in text and string 145 position in string j=6 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters match − decrement position in text and string 146 position in string j=6 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters match − decrement position in text and string 147 position in string j=5 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Compare characters in text and string 148 position in string j=5 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters do not match − case 1: the last position of character b in s is before position j − move s so last b in s is aligned with that of t that was mismatched − and start comparisons from end of the string 149 position in string j=5 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Characters do not match − case 1: the last position of character b in s is before position j − move s so last b in s is aligned with that of t that was mismatched − and start comparisons from end of the string 150 position in string j=6 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Compare characters in text and string 151 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Characters match − decrement position in text and string 152 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Characters match − decrement position in text and string 153 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=5 Boyer Moore - Example Compare characters in text and string 154 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=5 Boyer Moore - Example Characters do not match − case 1: the last position of character b in s is before position j − move s so last b in s is aligned with that of t that was mismatched − and start comparisons from end of the string 155 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=5 Boyer Moore - Example Characters do not match − case 1: the last position of character b in s is before position j − move s so last b in s is aligned with that of t that was mismatched − and start comparisons from end of the string 156 position in string j=6 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b Boyer Moore - Example Compare characters in text and string 157 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Compare characters in text and string 158 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Characters match − decrement position in text and string 159 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=6 Boyer Moore - Example Characters continue to match so − decrement position in text and string 160 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=5 Boyer Moore - Example Characters continue to match so − decrement position in text and string 161 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=4 Boyer Moore - Example Characters continue to match so − decrement position in text and string 162 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=3 Boyer Moore - Example Characters continue to match so − decrement position in text and string 163 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=2 Boyer Moore - Example Characters continue to match so − decrement position in text and string 164 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=1 Boyer Moore - Example Characters continue to match so − decrement position in text and string 165 b a b a c aastring/pattern s a c b a b a b a bbtext t a c a a b position in string j=0 Boyer Moore - Example String/pattern has been found 166 a c b a b a b a bbtext t a c a a b position in string j=-1 b a b a c aastring/pattern s Boyer Moore – application example Detecting malware signatures in network traffic One of the critical challenges in cybersecurity is to quickly and accurately detect malware signatures within the vast amount of data passing through a network. As cyber threats evolve, malware becomes more sophisticated, often embedding itself in legitimate network traffic to avoid detection. Security systems must inspect packets of data in real-time to identify these threats without significantly impacting network performance. 167 Boyer Moore – application example Detecting malware signatures in network traffic Why use the BM algorithm: − efficient string matching: • use it for scanning network packets for known malware signatures • skipping over non-matching portions of the packets allows for rapid analysis, minimising the impact on network performance − enhanced accuracy: • the algorithm can be tuned to match exact strings (signatures) of various malware, reducing the chances of false positives and negatives − scalability with network demand: • the algorithm's performance advantage grows with the length of the text (or packet size) being searched hence making it a scalable solution for malware detection in high-speed networks 168 Section 2 – Strings and text algorithms Text compression − Huffman encoding − LZW compression/decompression String comparison − string distance String/pattern search − brute force algorithm − KMP algorithm − BM algorithm 169 Outline of course Section 0: Quick recap on algorithm analysis Section 1: Sorting algorithms Section 2: Strings and text algorithms Section 3: Graphs and graph algorithms – next week! Section 4: An introduction to NP completeness Section 5: A (very) brief introduction to computability 170 Remember! Quiz for Week 1 opens up today at 12:00 up until tomorrow 23:59 Tutorial session tomorrow 2 hours to catch up with the tutorial exercises of this week 171","libVersion":"0.3.2","langs":""}