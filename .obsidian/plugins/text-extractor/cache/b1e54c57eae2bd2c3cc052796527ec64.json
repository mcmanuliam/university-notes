{"path":"Year 2/Data Storage and Retrieval/slides/DSR-L08-SQL (1).pdf","text":"Data Storage and Retrieval Lecture 8 Structured Query Language (SQL) Dr. Graham McDonald Graham.McDonald@glasgow.ac.uk Relational Algebra (RA) Three basic types of Relational Algebra operators: 1. Applying to one relation projection ∏ , selection σ (conditions) 2. Applying to two relations of identical structure union ⋃, intersection ⋂, difference - (no conditions) 3. Applying to two relations of different structure product × (no conditions) joins ⋈ (conditions) • RA is used directly in NoSQL • RA is used internally by SQL 2 SQL – “seequel” A database language, which allows the user to: • create database and relation structures • perform management tasks (insert, modify, delete) • perform simple and complex queries • SQL is non-procedural, you specify: • WHAT information you need • Not HOW to get it • “Intergalactic dataspeak”- an ISO standard • Various DBMS products (e.g.: MS Access, even MySQL) do not wholly conform to the ISO SQL standards 3 The January Census Animal House Person Feeds Stays LivesN 1 1 N N1 4 Person Animal aname type houseNum fedBy Fluffy dog 34 Jim Splodge cat 34 Jim Tinky dog 38 Robin dog 42 Jenny Red dog 42 Jim Dusty snake Jim name age houseNum Jim 15 34 Jo 23 38 Pete 20 38 Jenny 10 42 James 15 48 Paul 15 The January Census houseNum 34 38 42 48 House Animal House Person Feeds Stays LivesN 1 1 N N1 5 WHAT? Retrieve the names of residents in house number 42 who feed dogs 6 CONSTRAINTS? Retrieve the names of residents in house number 42 who feed dogs 7 SELECT • SELECT is the SQL command used to retrieve data • It takes a set of relations (tables) and describes the constraints that must be placed on them to return a given set of rows 8 Basic SQL Query Syntax SELECT [DISTINCT] target-list FROM relation-list WHERE qualification • relation-list is a list of relation names (possibly with “aliases”) • target-list is a list of attributes of relations in relation-list • qualification is a Boolean expression 9 SELECT [DISTINCT] target-list FROM relation-list WHERE qualification 10 WHERE is equivalent to relational selection operator Basic SQL Query Syntax SELECT [DISTINCT] target-list FROM relation-list WHERE qualification 11 FROM forms a Cartesian product of the tables/relations Basic SQL Query Syntax SELECT [DISTINCT] target-list FROM relation-list WHERE qualification 12 SELECT makes a projection of certain attributes GOTCHA: Relational Algebra vs. SQL Project ∏ => SELECT Select σ => WHERE Basic SQL Query SyntaxProjection ∏ Retrieving required columns from a relation name Jim Jo Pete Jenny James Paul SELECT name FROM Person; SELECT name, age FROM Person; name age Jim 15 Jo 23 Pete 20 Jenny 10 James 15 Paul 15 ∏ name [Person] ∏ name, age [Person] 13 Projection Over All Columns SELECT * FROM Person WHERE age = 15; σ (age=15) [Person] name age houseNum Jim 15 34 James 15 48 Paul 15 Selection σ Retrieving required rows from a relation SELECT name, houseNum FROM Person WHERE age = 15; name houseNum Jim 34 James 48 Paul ∏ name, houseNum (σ (age=15) [Person]) 15 SELECT type, fedBy FROM Animal WHERE fedBy = ‘Jim’; type fedBy dog Jim cat Jim dog Jim snake Jim ∏ type, fedBy (σ (fedBy=“Jim”) [Animal]) Unlike RA, there are duplicate rows! 16 Selecting Unique Rows SELECT type, fedBy FROM Animal WHERE fedBy = ‘Jim’; type fedBy dog Jim cat Jim dog Jim snake Jim SELECT DISTINCT type, fedBy FROM Animal WHERE fedBy = ‘Jim’; type fedBy dog Jim cat Jim snake Jim ∏ type, fedBy (σ (fedBy=‘Jim’) Animal) Unlike RA, SQL does not automatically remove duplicates. We need to request this explicitly 17 Other Operators from Relational Algebra • The SQL standard has equivalents to the RA operators ∪, ∩ and - • UNION • INTERSECT • MINUS/EXCEPT Ø (In fact, MySQL only implements UNION) • The Cartesian product X and joins are very important 18 Set Union ∪ AllPeople := ∏ name, age [Person] ∪ ∏ name,age [Person] People15-20 := ∏ name (σ (age=15 or age=20) [AllPeople] ) name Jim Pete James Paul (SELECT name FROM Person WHERE age=15) UNION (SELECT name FROM Person WHERE age=20); Remember Union Compatibility: Same number of columns, with matching datatypes. 1920 Cartesian Product × Combination of all rows and columns SELECT name, age, person.houseNum, aname, type, animal.houseNum, fedBy FROM Person, Animal; SELECT * FROM Person, Animal; person animal× Dot operator Cartesian product of all relations in the FROM aname type houseNum fedBy Fluffy dog 34 Jim Splodge cat 34 Jim Tinky dog 38 Robin dog 42 Jenny Red dog 42 Jim Dusty snake Jim name age houseNum Jim 15 34 Jo 23 38 Pete 20 38 Jenny 10 42 James 15 48 Paul 15 The January Census Person Animal SELECT * FROM Person, Animal 21 name age Person.houseNum aname type Animal.houseNum fedBy Jim 15 34 Fluffy dog 34 Jim Jim 15 34 Splodge cat 34 Jim Jim 15 34 Tinky dog 38 Jim 15 34 Robin dog 42 Jenny Jim 15 34 Red dog 42 Jim Jim 15 34 Dusty snake Jim Jo 23 38 Fluffy dog 34 Jim Jo 23 38 Splodge cat 34 Jim Jo 23 38 Tinky dog 38 Jo 23 38 Robin dog 42 Jenny Jo 23 38 Red dog 42 Jim Jo 23 38 Dusty snake Jim Pete 20 38 Fluffy dog 34 Jim Pete 20 38 Splodge cat 34 Jim Pete 20 38 Tinky dog 38 Pete 20 38 Robin dog 42 Jenny Pete 20 38 Red dog 42 Jim Pete 20 38 Dusty snake Jim Jenny 10 42 Fluffy dog 34 Jim Jenny 10 42 Splodge cat 34 Jim Jenny 10 42 Tinky dog 38 Jenny 10 42 Robin dog 42 Jenny Jenny 10 42 Red dog 42 Jim Jenny 10 42 Dusty snake Jim James 15 48 Fluffy dog 34 Jim James 15 48 Splodge cat 34 Jim James 15 48 Tinky dog 38 James 15 48 Robin dog 42 Jenny James 15 48 Red dog 42 Jim James 15 48 Dusty snake Jim Paul 15 Fluffy dog 34 Jim Paul 15 Splodge cat 34 Jim Paul 15 Tinky dog 38 Paul 15 Robin dog 42 Jenny Paul 15 Red dog 42 Jim Paul 15 Dusty snake Jim 22 Recall: Cartesian Product The Cartesian Product of two relations A and B, (with attributes A1 ... Am and B1 ... Bn), is a relation with m + n attributes containing a row for every pair of rows (one from A and one from B) Thus if A has a tuples and B has b tuples then the result has a * b tuples, with m+n attributes 23 Equi-join - ⋈A=B An Equi-join is the cartesian product, followed by a selection SELECT Person.name FROM Person, Animal WHERE Person.houseNum = Animal.houseNum; ∏ person.name (σ(person.houseNum=animal.HouseNum)(Person × Animal)) Dot operatorDot operator 24 name age Person. houseNum aname type Animal. houseNum fedBy Jim 15 34 Fluffy dog 34 Jim Jim 15 34 Splodge cat 34 Jim Jo 23 38 Tinky dog 38 Pete 20 38 Tinky dog 38 Jenny 10 42 Robin dog 42 Jenny Jenny 10 42 Red dog 42 Jim SELECT * FROM Person, Animal WHERE Person.houseNum = Animal.houseNum; σ(person.houseNum=animal.HouseNum)(Person × Animal) 25 Natural Join - ⋈ product + condition that all attributes of the same name be equated, then only one column for each pair of equated attributes is projected out SELECT * FROM Person NATURAL JOIN Animal; Person ⋈ Animal 2627 name age Person. houseNum aname type fedBy Jim 15 34 Fluffy dog Jim Jim 15 34 Splodge cat Jim Jo 23 38 Tinky dog Pete 20 38 Tinky dog Jenny 10 42 Robin dog Jenny Jenny 10 42 Red dog Jim SELECT * FROM Person NATURAL JOIN Animal; SELECT name, age, Person.houseNum, aname, type, fedBy FROM Person, Animal WHERE Person.houseNum = Animal.houseNum; person ⋈ animal 28 Renaming The reserved word AS can be used to define aliases for attributes or relations: SELECT p.name, age, p.houseNum, a.aname, type, a.houseNum, fedBy FROM Person AS p, Animal AS a WHERE p.houseNum = a.houseNum; SELECT p.name AS pn, age, p.houseNum AS ph a.aname AS an, type, a.houseNum AS ah, fedBy FROM Person AS p, Animal AS a WHERE ph = ah; Relations: Attributes: 29 E.name S.name J Jones J Smith J Brown J Smith J Smith J Jones Renaming is needed when you have to use the same table twice in the same query SELECT E.name, S.name FROM Employee AS E, Employee AS S WHERE(E.supervisor = S.NI#) NI# name DoB DNo Supervisor 1001 J Smith 23/2/54 14 null 1002 J Jones 24/5/73 11 1001 1003 J Brown 24/7/80 14 1001 1004 J Smith 24/6/76 14 1002 Employee Useful for querying across recursive relationships 29 Using the Same Table TwiceUsing the Same Table Twice NI# name Sup'r S.NI name 1001 J Smith null 1001 J Smith 1001 J Smith null 1002 J Jones 1001 J Smith null 1003 J Brown 1001 J Smith null 1004 J Smith 1002 J Jones 1001 1001 J Smith 1002 J Jones 1001 1002 J Jones 1002 J Jones 1001 1003 J Brown 1002 J Jones 1001 1004 J Smith 1003 J Brown 1001 1001 J Smith 1003 J Brown 1001 1002 J Jones 1003 J Brown 1001 1003 J Brown 1003 J Brown 1001 1004 J Smith 1004 J Smith 1002 1001 J Smith 1004 J Smith 1002 1002 J Jones 1004 J Smith 1002 1003 J Brown 1004 J Smith 1002 1004 J Smith E S E x S 30 31 Using the Same Table Twice NI# name Sup'r S.NI name 1001 J Smith null 1001 J Smith 1001 J Smith null 1002 J Jones 1001 J Smith null 1003 J Brown 1001 J Smith null 1004 J Smith 1002 J Jones 1001 1001 J Smith 1002 J Jones 1001 1002 J Jones 1002 J Jones 1001 1003 J Brown 1002 J Jones 1001 1004 J Smith 1003 J Brown 1001 1001 J Smith 1003 J Brown 1001 1002 J Jones 1003 J Brown 1001 1003 J Brown 1003 J Brown 1001 1004 J Smith 1004 J Smith 1002 1001 J Smith 1004 J Smith 1002 1002 J Jones 1004 J Smith 1002 1003 J Brown 1004 J Smith 1002 1004 J Smith E S 31 E x S 32 Basic SQL - reminder SELECT target attribute(s) FROM relation(s) WHERE qualification condition(s) ORDER MATTERS. It is NOT FROM relation(s) WHERE qualification SELECT attributes 32 • We have taken care of the following core relational algebra operations in SQL: • Projection (columns) • Selection (rows) • Intersection • Difference • Union • Cartesian products and joins • Renaming 33 Mapping to Relational Algebra • The simple query SELECT a1, …, an FROM R1, …, Rm WHERE b; • Can be mapped to the RA expression: pa1,…,an(sb(R1´…´Rm)) (Assuming no duplicates) 34 Semantics of SQL Queries • The semantics of SQL query evaluation can be conceptually defined as: • Compute the product of relation-list • Discard those tuples that fail the qualification • Delete attributes that are not in target-list • If DISTINCT is specified, eliminate duplicate rows 35 WHERE Options WHERE age > 15 WHERE age < > 18 WHERE age = 15 AND houseNum IS NOT NULL WHERE houseNum IS NULL WHERE age BETWEEN 10 AND 20 WHERE (type = ‘dog’) OR (type = ‘cat’) WHERE name LIKE ‘J%’ (names beginning with J) LIKE ‘J_ _ _ _’ (5 letter names beginning with J) LIKE ‘_ _ M %’ (names with M as the third letter) SQL provides powerful string matching facilities % denotes zero or more characters _ denotes any one character Combine using AND, OR; use brackets to denote precedence 36 Operator Precedence SELECT name FROM Person WHERE age = 23 AND houseNum = 38 OR houseNum = 48 37 name age houseNum Jim 15 34 Jo 23 38 Pete 20 38 Jenny 10 42 James 15 48 Paul 15 name Jo name James Jo SELECT name FROM Person WHERE age = 23 AND (houseNum = 38 OR houseNum = 48) SELECT name FROM Person WHERE (age = 23 AND houseNum = 38) OR houseNum = 48 (a) (b) Operator Precedence (2) • Different operators (+ - * OR AND) have higher precedence • This means they are evaluated before others • E.g. * before +, so 5*4 + 2 = 22, not 30 • E.g. AND before OR WHERE (age = 23 AND houseNum = 38) OR houseNum = 48 • If you aren’t sure about which operator has precedence, then use brackets • Even if you are, other people reading your SQL might not be! 3839 (SELECT name FROM Person WHERE houseNum = 34) UNION (SELECT name FROM Person WHERE houseNum = 38) SELECT name FROM Person WHERE houseNum = 34 OR houseNum = 38 What is the connection between UNION, INTERSECT & AND, OR? name Jim Jo Pete name Jim Jo Pete Calculated Attributes: Extended Projection Specify a calculation to be performed on the values of an attribute: SELECT name, age*age, houseNum-2 FROM Person; name val1 val2 Jim 225 32 Jo 529 36 Pete 400 36 Jenny 100 40 James 225 48 Paul 225 40 Example • Specify a calculation to be performed on values of an attribute (and use renaming) 41 SELECT name, age*age AS agesquare, houseNum-2 AS nextdoor FROM Person; name agesquare nextdoor Jim 225 32 Jo 529 36 Pete 400 36 Jenny 100 40 James 225 48 Paul 225 42 Ordering • Theoretically, rows in a relation have no order (being a set) • SQL can order the rows: we can specify the order criteria SELECT * FROM Person ORDER BY age; name age houseNum Jenny 10 42 James 15 48 Paul 15 Jim 15 34 Pete 20 38 Jo 23 38 SELECT * FROM Person ORDER BY age DESC, name; name age houseNum Jo 23 38 Pete 20 38 James 15 48 Jim 15 34 Paul 15 Jenny 10 42 Age “ties” broken by name 43","libVersion":"0.3.2","langs":""}