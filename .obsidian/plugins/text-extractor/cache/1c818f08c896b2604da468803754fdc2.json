{"path":"university/year 2/semester 1/Practical Algorithms/Slides/3. Data Collections/Hashmaps.pdf","text":"Practical Algorithms Yiannis Giannakopoulos (with thanks to Michele Sevegnani) School of Computing Science University of Glasgow Practical Algorithms 2024 Maps & Hash Tables 2PA, 2024 The Map ADT Dictionaries: Motivation • Many real-life data sets consist of (key,value) entries • Examples: − (URL, IP address) − (student ID, grade) • Abstraction of a (partial) function: 3PA, 2024 (“universe” of) keys values www.glasgow.ac.uk ☞ 130.209.16.93 The Map ADT • A map models a dynamic and searchable collection of (key,value) pairs (called entries or elements) − Other names: associative array, dictionary, symbol table, … − Multiple entries with the same key are not allowed (keys must be unique) • Main map operations − INSERT(M,k,v): add an entry (k,v) to map M − DELETE(M,k): remove the entry with key k from map M (return NIL if it does not exist) − SEARCH(M,k): return the value v of the entry with key k in map M (return NIL if it does not exist) • Auxiliary map operation − IS-EMPTY(M): test whether M contains no entries (returns a Boolean value) 4PA, 2024 Example: ASCII • ASCII character encoding (128 entries) − keys: integers {0,1,…,127}, values: characters 5PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) − INSERT(M, 71, ‘G’) − INSERT(M, 113, ‘q’) − INSERT(M, 109, ‘m’) − SEARCH(M, 65) − INSERT(M, 83, ‘S’) − DELETE(M, 113) − SEARCH(M, 113) 6PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) − INSERT(M, 113, ‘q’) − INSERT(M, 109, ‘m’) − SEARCH(M, 65) − INSERT(M, 83, ‘S’) − DELETE(M, 113) − SEARCH(M, 113) 7PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) − INSERT(M, 109, ‘m’) − SEARCH(M, 65) − INSERT(M, 83, ‘S’) − DELETE(M, 113) − SEARCH(M, 113) 8PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’)} − INSERT(M, 109, ‘m’) − SEARCH(M, 65) − INSERT(M, 83, ‘S’) − DELETE(M, 113) − SEARCH(M, 113) 9PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’)} − INSERT(M, 109, ‘m’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’)} − SEARCH(M, 65) − INSERT(M, 83, ‘S’) − DELETE(M, 113) − SEARCH(M, 113) 10PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’)} − INSERT(M, 109, ‘m’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’)} − SEARCH(M, 65) return: ‘A’ − INSERT(M, 83, ‘S’) − DELETE(M, 113) − SEARCH(M, 113) 11PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’)} − INSERT(M, 109, ‘m’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’)} − SEARCH(M, 65) return (65, ‘A’) − INSERT(M, 83, ‘S’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’), (83, ‘S’)} − DELETE(M, 113) − SEARCH(M, 113) 12PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’)} − INSERT(M, 109, ‘m’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’)} − SEARCH(M, 65) return (65, ‘A’) − INSERT(M, 83, ‘S’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’), (83, ‘S’)} − DELETE(M, 113) M = {(65, ‘A’), (71, ‘G’), (109, ‘m’), (83, ‘S’)} − SEARCH(M, 113) 13PA, 2024 Example: ASCII M = {} − INSERT(M, 65, ‘A’) M = {(65, ‘A’)} − INSERT(M, 71, ‘G’) M = {(65, ‘A’), (71, ‘G’)} − INSERT(M, 113, ‘q’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’)} − INSERT(M, 109, ‘m’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’)} − SEARCH(M, 65) return (65, ‘A’) − INSERT(M, 83, ‘S’) M = {(65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’), (83, ‘S’)} − DELETE(M, 113) M = {(65, ‘A’), (71, ‘G’), (109, ‘m’), (83, ‘S’)} − SEARCH(M, 113) return NIL 14PA, 2024 Map Implementations What is the “best” way to implement such a data structure? 15PA, 2024 • We can implement a map using a doubly-linked list: − Values are stored as satellite data (attribute if small, pointer for larger structures) • Performance − INSERT takes O(1) time (O(n) if we first check for duplicates) − SEARCH and DELETE take O(n) – we need to traverse the entire list to look for an entry • The list-based implementation is recommended only for maps of small size • Can we do better? List-based Implementation 16PA, 2024 satellite data - pointer M.head 65 A 71 G 113 qkey value Tree-based Implementation • Using a self-balancing trees we can guarantee a worst-case running time of: − O(log n) for all the main map ADT operations • Additionally, an in-order traversal allows us to get a sorted sequence of all the pairs stored in the map • Can we do even better? 17PA, 2024 A65 G71 m109 q113 key value satellite data - attribute Direct-address Tables • Assumptions − Each element of our map M has an integer key drawn from the universe U = {0,1,…, m – 1} − Recall: no two elements have the same key • Α direct-address table is an array T[0,..,m - 1] that can represent map M in the following way: − Each position (also called slot or bucket) in T corresponds to a key in the universe U − Slot k contains/points to the value of the element M with key k • In other words: if (k,v)∈M then T[k]=v. − If no element has key k, then T[k] = NIL 18PA, 2024 T A G m q … slot 65 … 70 71 … 109 110 111 112 113 … 127 1 0 key value NIL Direct-address Table: Map Implementation • Operations are trivial to implement − Each operation takes O(1) time • However, what if: 1. The keys are not natural numbers? 2. The universe U is much larger than the “actual” number of keys that we are expecting to use, i.e |U| ≫ m ? • Hashing deals with issues 1. and 2. by: 1. Encoding 2. Compression 19PA, 2024 DIRECT-ADDRESS-INSERT(T,x) T[x.key] = x.value DIRECT-ADDRESS-SEARCH(T,k) return T[k] DIRECT-ADDRESS-DELETE(T,k) T[k] = NIL element x = (key,value) 20PA, 2024 Hash Tables Hashing: Overview 21PA, 2024 hash code compression hash table T 0 1 2 m-1 universe U keys natural numbers values hash function The Hash Table Data Structure • Generalizes direct-address tables by adding a hash function • Consists of: 1. An array T[0,..,m - 1] of fixed size m (called hash table or bucket array) 2. A hash function h: U → {0,1,…,m - 1} mapping keys to slots of T • Hash collision: when two keys are mapped to the same slot of the hash table − That is, h(k1)=h(k2) for k1≠k2 (where k1,k2 ∈ U) − In general, hash collisions are unavoidable (if |U| > m) − However: a “good” hash function spreads keys as “evenly” as possible over the slots of T ➢ Each backet should be used with equal probability for data randomly sampled from the universe U • Additionally: hash functions should be “simple” and fast to compute • Under the above assumptions: hash tables support INSERT, DELETE and SEARCH operations in O(1) time “on average” 22PA, 2024 Example: ASCII • ASCII table with hash function h(k) = k mod 8 − U = {0,1,…,127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) in hash table T 23PA, 2024 Tindex 1 0 6 7 5 4 3 2 Example: ASCII • ASCII table with hash function h(k) = k mod 8 − U = {0,1,…,127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) 24PA, 2024 A65 Tindex 1 0 6 7 5 4 3 2 − INSERT(T, (65, ‘A’)) − h(65) = 65 mod 8 = 1 − Insert element in slot 1 Example • ASCII table with hash function h(k) = k mod 8 − U = {0,…127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) 25PA, 2024 A65 Tindex 1 0 6 7 5 4 3 2 − INSERT(T, (71, ‘G’)) − h(71) = 71 mod 8 = 7 − Insert element in slot 7 G71 Example • ASCII table with hash function h(k) = k mod 8 − U = {0,…127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) 26PA, 2024 A65 Tindex 1 0 6 7 5 4 3 2 − INSERT(T, (113, ‘q’)) − h(113) = 113 mod 8 = 1 − Insert element in slot 1, but slot 1 is already occupied − We say that keys 65 and 113 collide G71 Example • ASCII table with hash function h(k) = k mod 8 − U = {0,…127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) 27PA, 2024 q113 Tindex 1 0 6 7 5 4 3 2 − INSERT(T, (113, ‘q’)) − h(113) = 113 mod 8 = 1 − A (bad, in general) strategy to resolve collisions is to store only the most recent key/value − We will study more sophisticated strategies to resolve collisions later in these lectures G71 Example • ASCII table with hash function h(k) = k mod 8 − U = {0,…127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) 28PA, 2024 q113 Tindex 1 0 6 7 5 4 3 2 − INSERT(T, (109, ‘m’)) − h(109) = 109 mod 8 = 5 − Insert element in slot 5 G71 m109 Example • ASCII table with hash function h(k) = k mod 8 − U = {0,…127} and size of hash table T is m = 8 • Insert (65, ‘A’), (71, ‘G’), (113, ‘q’), (109, ‘m’) and (83, ‘S’) 29PA, 2024 q113 Tindex 1 0 6 7 5 4 3 2 − INSERT(T, (83, ‘S’)) − h(83) = 83 mod 8 = 3 − Insert element in slot 3 G71 m109 S83 30PA, 2024 Encoding Encoding general keys as natural numbers • Most hash functions operate on natural numbers, ie they assume as a universe of keys U = ℕ • There are several methods (called hash codes) to convert/encode an arbitrary object as a natural number, e.g. − Integer casting − Component sum − Memory address − Polynomial hashing • Here we will only describe integer casting and component sum here, very briefly. 31PA, 2024 Integer Casting • Most data types have a “natural” bit representation, in every programming language • So, we can use as key the integer corresponding to that binary number • Example: 100112 = 1910 • For example: Python uses 64-bit values to encode many fundamental types, e.g. float and int • So, integer casting can be readily used for types: • For longer types, e.g. strings, we need to perform some kind of “merging” • For example, an object (𝒙𝟎, 𝒙𝟏, … , 𝒙𝒏−𝟏) where all 𝒙𝒊 are 64-bit integers can be represented as o σ𝑖=0 𝑛−1 𝑥𝑖, or o 𝑥0⨁ 𝑥1 ⨁ ⋯ ⨁ 𝑥𝑛−1, where ⨁ is the XOR operator ➢ This is known as component sum hashing 32PA, 2024 36PA, 2024 Compression: Hash Functions ℕ ⟶ {0,1, … , 𝑚 − 1} Truncation • Take the first/last few digits of the key − Problem: it may generate many collisions if there are regularities in the input keys • Example − Student IDs consisting of 8 digits: 2023 1734 − Numbers are assigned sequentially − Students in a given class/year will tend to have IDs close together, and all beginning with the same first few digits − But: taking the last three digits will work a lot better! 37PA, 2024 Division • Map a key k into one of m slots by taking the remainder of the division of k by m − The hash function is h(k) = k mod m ➢ Python: k % m • Good practice: to ensure that data is distributed fairly, we usually choose the table size m to be − Prime − Not “too close” to an exact power of 2 • If m = 2p, then h(k) is just the p lowest-order bits of k ▪ Examples: 1010112 % 102 = 12, 1010112 % 1002 = 112 ▪ The analogous case for decimal numbers would be division by powers of 10: 23410 % 1010 = 410, 23410 % 10010 = 3410 • If use of lower-order bits is suitable, better to simply truncate 38PA, 2024 Example: Hashing by Division • Suppose we want to allocate a hash table to hold roughly 5000 keys • We pick m to be a prime close to 5000 but not near any power of 2 − 212 = 4069 − 213 = 8192 • Primes near 5000: − 4987, 4993, 4999, 5003, 5009, 5011 • So, our hash function could be h(k) = k mod 5003 39PA, 2024 41PA, 2024 Collision Resolution 42PA, 2024 Chaining Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 43PA, 2024 T 2 slot 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 44PA, 2024 T 2 slot 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 45PA, 2024 T 2 slot 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 46PA, 2024 G71 K75 T 2 slot 3 4 5 6 7 8 1 0 key value z122 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 47PA, 2024 G71 K75 T 2 3 4 5 6 7 8 1 0 z122 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 slot Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 48PA, 2024 G71 K75 T 2 3 4 5 6 7 8 1 0 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 %37 z122 slot Collision Resolution by Chaining • Each slot of the hash table points to its own (doubly) linked list (called chain) • All elements that hash to the same slot are stored in that slot’s list − List T[i] holds elements (k,v) for which h(k)=i, i=0,1,…,m-1 • Example: ASCII with m=9 • U = {0, …,127} • Insert key sequence: 122, 71, 75, 37, 65, 109 • Assume that we use a hash function h: U → {0,…,8} such that: 49PA, 2024 A65 G71 m109 K75 T 2 3 4 5 6 7 8 1 0 %37 z122 h(37) = h(65) = h(122) = 3 h(71) = 6 h(75) = h(109) = 8 slot 59PA, 2024 Open-Address Hashing Collision Resolution by Open Addressing • General scheme: if a collision occurs, an alternative cell is tried (or “probed”) until an empty cell is found − Appropriate when memory availability is limited, and we cannot use auxiliary data structures (like linked lists in chaining) − The load factor needs to be at most α≤ 1: otherwise, we may overflow the hash table • Rigorously, open addressing can be modelled by adding an extra parameter to our hash function: h: U × {0,1,…,m-1} → {0,1,…,m-1} where h(k,i) gives the slot that we should probe at our i-th try. − Implicit assumption: each key should probe all slots − Formally, this means that ( h(k,0), h(k,1), …, h(k,m-1) ) is a permutation of (0, 1,…, m-1), for all k∈U 60PA, 2024 Open Addressing: Insertion • For a given hash function h(k,i), the HASH-INSERT procedure takes as input a hash table T and a key k and − Returns the slot number where it stores k, or − Raises an error because T is already full 61PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error “hash table overflow” Example: Linear Probing • Hashing by division into a table of size m=8 • Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) − i.e. h(k,i) = (k+i) mod 8 62PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error “hash table overflow” 113 Tslot 1 0 6 7 5 4 3 2 71 109 83 Example: Linear Probing • Hashing by division into a table of size m=8 • Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) − i.e. h(k,i) = (k+i) mod 8 63PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = (k+i) % m if T[j] == NIL T[j] = k return j else i = i + 1 error “hash table overflow” 113 Tslot 1 0 6 7 5 4 3 2 − INSERT(T, 65) − h(65) = 65 mod 8 = 1 − Collision 71 109 83 Example: Insertion • Hashing by division into a table of size m=8 • Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) − i.e. h(k,i) = (k+i) mod 8 64PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error “hash table overflow” 113 Tslot 1 0 6 7 5 4 3 2 71 109 83 65 − INSERT(T, 65) − h(65) = 65 mod 8 = 1 − Insert element in slot 2 Example: Insertion • Hashing by division into a table of size m=8 • Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) − i.e. h(k,i) = (k+i) mod 8 65PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error “hash table overflow” 113 Tslot 1 0 6 7 5 4 3 2 − INSERT(T, 57) − h(57) = 57 mod 8 = 1 − Collision 71 109 83 65 Example: Insertion • Hashing by division into a table of size m=8 • Open addressing by sequentially probing slot i+1 after slot i (wrapping around when i = m) − i.e. h(k,i) = (k+i) mod 8 66PA, 2024 HASH-INSERT(T,k) i = 0 while i < m j = h(k,i) if T[j] == NIL T[j] = k return j else i = i + 1 error “hash table overflow” 113 Tslot 1 0 6 7 5 4 3 2 − INSERT(T, 57) − h(57) = 57 mod 8 = 1 − Insert element in slot 4 57 71 109 83 65 Hashing: Further Reading “Introduction to Algorithms” (4th edition) by Cormen, Leiserson, Rivest, and Stein Chapter 11 “Algorithms Illuminated” (Omnibus edition) by Roughgarden Chapter 12 PA, 2024 67","libVersion":"0.3.2","langs":""}