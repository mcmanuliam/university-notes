{"path":"Software Engineering/Year 2/Practical Algorithms/Slides/5. Searching and Sorting/14. Searching.pdf","text":"Searching Searching â€¢ The algorithmic process of finding a particular item in a collection of items. â€¢ Use-cases: â€¢ Membership test (is this item present?) â€¢ Return item/position if found â€¢ We will focus on membership test â€¢ returning the item if found, is a small modification The Python way â€¢ A lot algorithms we will (tediously) manually build from the ground up, are already available in the basic Python or in a Python library. â€¢ E.g. (code visualization) â€¢ But using them defeats the purpose of the course. â€¢ So, we will skip the Tardis and take the long route... â€¢ We will build (and analyze) search functions from the ground up This Photo by Unknown Author is licensed under CC BY-NC-ND Search in singly linked lists â€¢ Find the first element with key k in list L by a simple linear search âˆ’ If found, return a pointer to this element âˆ’ If no object with key k appears in the list, then return NIL â€¢ Iterator pattern â€¢ Complexity O(n) â€¢ Example âˆ’ Find k=3 in the list below L.head 1 3 3 5 SEARCH(L,k) i := L.head while i != NIL and i.key != k i := i.next return i Search in binary search trees â€¢ Search for a node with a given key in a BST âˆ’ Given a pointer to the root of the tree node and a key k, return a pointer to a node with key k if one exists; return NIL otherwise â€¢ Recursive definition âˆ’ Start with searching at the root node âˆ’ If k is smaller than node.key, continue the search in the left subtree of node âˆ’ The search continues in the right subtree otherwise â€¢ A recursive algorithm works well here, because the data structure itself is recursive âˆ’ Complexity: O(h); can be O(log n) if balanced SEARCH(node,key) if node==NIL or k==node.key return node if k < node.key return SEARCH(node.left,key) else return SEARCH(node.right,key) â€¢ The correctness of the procedure follows from the binary-search-tree property The Sequential Search An excuse for understanding the â€œincremental approachâ€ to algorithm design The Sequential Search Code visualization for self-study This is the search you would do when looking for â€œname against numberâ€ in a telephone book. Items in a sequence, no order to them. You start at one end, go all the way to the other (or until you find the item) Letâ€™s code! Code visualization for self-study An excuse for understanding â€œincremental approachâ€ to algorithm design Sequential Search Best case ? Worst case ? If item is present: Best case ? Worst case ? If item is not present: â€¢ â€œNaÃ¯veâ€ approach: â€¢ Keep searching â€œmyopicallyâ€ â€¢ Start from one end and go all the way to the other, until you find the item â€¢ No use of additional structural properties of the underlying data structure, like ordering ComplexitySequential Search Best case ð‘‚(1) Worst case ð‘‚(ð‘›) If item is present: Best case ð‘‚(ð‘›) Worst case ð‘‚(ð‘›) If item is not present: â€¢ â€œNaÃ¯veâ€ approach: â€¢ Keep searching â€œmyopicallyâ€ â€¢ Start from one end and go all the way to the other, until you find the item â€¢ No use of additional structural properties of the underlying data structure, like ordering Complexity* * Where ð‘› is the size of the array/data structure we are searching in Algorithmic design patterns: Incremental Approach â€¢ We are going to use searching and sorting as a means to understanding some common algorithmic design patterns â€¢ The one you just saw in the sequential search, is called the incremental approach to algorithm design. â€¢ Basically: solution works: one element at a time â€¢ or, equivalently, one element each step â€¢ O(n) complexity algorithm What if? â€¢ The list was ordered? â€¢ We can stop searching when go past the value of interest? â€¢ Letâ€™s code! â€¢ Link to code visualization for self-review Have we really used the sorted list to our advantage? â€¢ We are still at O(n) complexity â€¢ You reduce the time/steps only for the case where the item is not in the list â€¢ In the worst case (item not present or is at the last location), we still have to iterate through the entire list â€¢ How would you go about searching for a name in a sorted directory/dictionary? â€¢ Or a number in a sorted deck of numbered cards? The Binary Search â€¢ We can take greater advantage of the ordered list if we be a bit clever â€¢ E.g., looking for 100 in [1,2,3,4,15,17,19,20,21,25,28,100,120] 1 2 3 4 15 17 19 20 21 25 28 100 120 The Binary Search Algorithm 1. Look at the middle value; then 2. if search item is greater than the value at the middle, it must be on its right. Discard middle item and left half. Repeat 1 3. if search item is less than the value at the middle, it must be on its left. Discard the middle item and right half. Repeat 1 4. If the middle item is the search item, or no more elements left, exit. The Divide and Conquer Algorithmic Pattern â€¢ Binary search is a great example of this pattern â€¢ In general: divide and conquer means we: â€¢ divide the problem into smaller pieces, â€¢ solve the smaller pieces, and then â€¢ (if applicable) reassemble the problem back up to get the result â€¢ Very often you can program it using a recursive function This Photo by Unknown Author is licensed under CC BY-SA-NC Letâ€™s code this gremlin 1. Look at the middle value; then 2. if search item is greater than the value at the middle, it must be on its right. Discard middle item and left half. Repeat 1 3. if search item is less than the value at the middle, it must be on its left. Discard the middle item and right half. Repeat 1 4. If the middle item is the search item, or no more elements left, exit. Link to code and visualization Analysing Binary search â€¢ When problem size is halved in every step, this is O(log n) complexity â€¢ Or: Analysing Binary search â€¢ When problem size is halved in every step, this is O(log n) complexity â€¢ Or:","libVersion":"0.3.2","langs":""}